Technical things all

1.JWT -jwt & Swagger setting 
2.Annotations
3.Role and Permission settings
4.Create NuGet Package and install
5.Db Connection 
6.ABP Framwork
7.Figma tool
8.Program.cs file explaination
9. NUnit Testing

***************************************************************************************************************************************
**************************************************************JWT Token Authentication*************************************************

A JWT (JSON Web Token) typically consists of three parts separated by dots (.).
# Header: 
This part typically consists of two parts: the type of token (which is JWT) and the signing algorithm being used (such as HMAC SHA256 or RSA). 
For example, a header might look like this:
{
  "alg": "HS256",
  "typ": "JWT"
}
-----------------------------------------------------------
# Payload: 
This part contains the claims. Claims are statements about an entity (typically the user) and additional data.
There are three types of claims: registered, public, and private claims. 
For example:
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,                ----role
  "Email": "abc"
}

-------------------------Extra Info-----------------------------------
Registered Claims: 
These are predefined claims which are not mandatory but recommended to provide a set of useful, interoperable claims. Some common registered claims include:

iss (issuer): Identifies the principal that issued the JWT.
sub (subject): Identifies the subject of the JWT.
aud (audience): Identifies the recipients that the JWT is intended for.
exp (expiration time): Specifies the expiration time after which the JWT should not be accepted.
nbf (not before): Specifies the time before which the JWT must not be accepted for processing.
iat (issued at): Specifies the time at which the JWT was issued.
jti (JWT ID): Provides a unique identifier for the JWT.
{
  "iss": "issuer",
  "sub": "subject",
  "aud": "audience",
  "exp": 1625939622,
  "nbf": 1625938022,
  "iat": 1625938022,
  "jti": "id123456"
}

-----------------------------------------------
Public Claims:
These are custom claims that are defined by users and application developers. They should be defined in a way that they do not clash with registered claims.
Example:
{
  "name": "John Doe",
  "role": "admin"
}
-----------------------------------------------
Private Claims: 
These are custom claims that are agreed upon between parties that use JWTs. They are neither registered nor public claims. 
Example:
{
  "custom_data": {
    "key1": "value1",
    "key2": "value2"
  }
}


-----------------------------------------------
what is Claims
In the context of authentication and authorization using JWT (JSON Web Token), claims refer to the pieces of information asserted about a subject (typically a user) within the token. 
Claims are statements about the subject that provide information such as identity, roles, permissions, and other attributes relevant to the application's security and functionality.

----------------------------------------------------------------------
# Signature: 
To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.

xxxxxxxxxx.yyyyyyyyyy.zzzzzzzzzz

 xxxxxxxxxx is the base64url encoded header
 yyyyyyyyyy is the base64url encoded payload
 zzzzzzzzzz is the signature

********************************************************Implemtation****************************************************************
JWT
# Download Microsoft.AspNetCore.Authentication.JwtBearer package.
	-Microsoft.AspNetCore.Authentication.JwtBearer: Provides the middleware that integrates JWT token authentication into ASP.NET Core applications, 
													handling the authentication process automatically during the request lifecycle.
# BCrypt.Net-Next -package for encrypt and deceypt password

	            u.Password =  BCrypt.Net.BCrypt.HashPassword(user.Password);          abs->asdfghj
                var pass = BCrypt.Net.BCrypt.Verify(user.Password, u.Password);        it check password compair and return boolean value.


 public string CreateToken(User user)
 {
     List<Claim> claims = new List<Claim>
	 {
		 new Claim(ClaimTypes.Name, user.UserName),
		 new Claim(JwtRegisteredClaimNames.Sub,iconfig["Jwt:Subject"]),
         new Claim(JwtRegisteredClaimNames.Jti,Guid.NewGuid().ToString()),
	 };

     var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(iconfig["Jwt:Key"]));   //1 
     var signIn = new SigningCredentials(key, SecurityAlgorithms.HmacSha512);          //2 
     var token = new JwtSecurityToken(

         iconfig["Jwt:Issuer"],                 
         iconfig["Jwt:Audience"],
         claims,
         expires: DateTime.UtcNow.AddMinutes(60),
         signingCredentials: signIn
         );                   

// token = {{"alg":"HS512","typ":"JWT"}.{"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name":"akash","sub":"JwtSubject","jti":"50058aea-7287-4695-b268-83397a720482","exp":1726913435,"iss":"JwtIssuer","aud":"JwtAudience"}}		 


     string tokenValue = new JwtSecurityTokenHandler().WriteToken(token);   //3

     return tokenValue;
 }
 
// tokenValue = "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9
				.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWthc2giLCJzdWIiOiJKd3RTdWJqZWN0IiwianRpIjoiNTAwNThhZWEtNzI4Ny00Njk1LWIyNjgtODMzOTdhNzIwNDgyIiwiZXhwIjoxNzI2OTEzNDM1LCJpciLCJhdWQiOiJKd3RBdWRpZW5jZSJ9
				.28gIsVUE2jPlxYshTW55a4_97So3Nwm5CPJYg9mKZczBlVK6yx28GTMmpbeDsl10eBPbHWDP2t8ZRUFcakbj8g"
 
 
 
 
1.
SymmetricSecurityKey: which will be used to sign and validate the JWT tokens. Symmetric keys mean the same key is used for both signing (creating the token) and verifying (validating the token).
2.
SigningCredentials: It encapsulates the information needed to sign the token, including the security key and the algorithm used for signing. 
3.
JwtSecurityTokenHandler:
This is a class from the System.IdentityModel.Tokens.Jwt namespace. It provides methods for creating, validating, and handling JWT tokens.
.WriteToken(token): This method takes a JwtSecurityToken object (referred to here as token) and converts it into a string format. This string representation is what you will send to the client as the actual JWT.



# What is the Issuer?
Issuer: The issuer is a claim that indicates who issued the JWT. It’s often used to help verify the authenticity of the token. When the token is created, the issuer value is included in the claims. When validating the token, you can check if the issuer matches the expected value.

#What is the Audience?
Audience: The audience claim (aud) specifies the intended recipient(s) of the token. It indicates who the token is meant for. This is useful for ensuring that the token is only processed by the intended consumer(s), adding an extra layer of security.
-------------------------------------------------------------Program.cs-----------------------------------------------------------------


builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateAudience = true,
            ValidateIssuer = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))

        };
    });
	
	
// Add authorization
builder.Services.AddAuthorization();

// Use authentication
app.UseAuthentication();

app.UseAuthorization();


	
-----------------------------------appsetting.json----------------------------------------
  "Jwt": {
    "Key": "asdfghjhgfdsdfghjkjhgfdsghjhgfdsdfghjjhg1234567890sdfdsasdfghjhgfdsdfghjkjhgfdsghjhgfdsdfghjjhg1234567890sdfds",
    "Issuer": "JwtIssuer",                      //who create token
    "Audience": "JwtAudience",					// for whom Crete token
    "Subject": "JwtSubject"
  }	
  -------------------------------------------to enable functionality where we pass token in swagger--------------------------------------------------------------
    
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "My API", Version = "v1" });     //Show in swagger 

    // Add JWT Bearer authentication to Swagger
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        In = ParameterLocation.Header,                                            //Where the token should be provided (in the header).
        Description = "Please enter a valid token",								  //Description: A brief guide on how to use the token.
        Name = "Authorization",													  //Name: The name of the header to include (in this case, "Authorization")
        Type = SecuritySchemeType.ApiKey,										  //Type: Specifies the scheme type (ApiKey for Bearer tokens).
        Scheme = "bearer",														  //Scheme: Indicates that it's a bearer scheme.
        BearerFormat="Jwt"														  //BearerFormat: Indicates the format of the token (JWT).
    });

    c.AddSecurityRequirement(new OpenApiSecurityRequirement                       //This section specifies that the defined Bearer token scheme is required for all API endpoints. 
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            new string[] {}
        }
    });
});

-----------------------------------------------------------Steps for add swagger in project-----------------------------------------------------------
1. install package -> Swashbuckle.AspNetCore
2. Add code -> program.cs -> 	builder.Services.AddEndpointsApiExplorer();
								builder.Service.AddSwaggerGen();
								App.UseSwaggerUI(options =>
								{
									options.SwaggerEndpoint(https://localhost:44301/) + _appConfiguration["App:SwaggerEndPoint"], "WealthMapper.Order V1");
								}); //URL: /swagger
								app.UseSwaggerUI();
								
								
************************************************************************************************************************************************								
*************************************************************Annotations************************************************************************

Annotations in ASP .Net core

[Required] : Specifies that a data field must be filled out.

[StringLength] : Sets the maximum length of a string field.

     [StringLength(100)]
     public string Name { get; set; }

[Range] : Validates that a numeric field falls within a specified range.
 
    [Range(1, 100)]
    public int Quantity { get; set; }
	
[EmailAddress] : Validates that a field contains a valid email address
	
	[EmailAddress]
    public string Email { get; set; }

[Compare] : Compares two properties to ensure they match, often used for password confirmation.
 
	[Required]
    public string Password { get; set; }

    [Compare("Password")]
    public string ConfirmPassword { get; set; }
	
[RegularExpression] : Validates that a field matches a specified regular expression pattern.

	 [RegularExpression(@"^[A-Z]+[a-zA-Z''-'\s]*$")]
    public string ProductName { get; set; }

[DataType] : Specifies the type of data for a field, which can affect how it's rendered in UI

	[DataType(DataType.Date)]
    public DateTime BirthDate { get; set; }
	
************************************************************************************************************************************************
****************************************************Role & Permission***************************************************************************

Role and Permission Managment

i1Core.Core.Sheard.Authorization.
AppPermissions
#we create All permissions 
public static class AppPermissions
{
	// Customer Permissions
	 public const string Pages_Customer = "Pages.Customer";
	 public const string Pages_Customer_Dashboard = "Pages.Customer.Dashboard";
	 public const string Pages_Customer_Contract = "Pages.Customer.Contract";
	 public const string Pages_Customer_Portfolio = "Pages.Customer.Portfolio";
	 public const string Pages_Customer_Suitability = "Pages.Customer.Suitability";
 }
---------------------------------------------------------------------------------------

i1Core.Core.Authorization.
AppAuthorizationProvider

#we Create Object and by using that we create child permissions

 public class AppAuthorizationProvider : AuthorizationProvider
 {
	 public override void SetPermissions(IPermissionDefinitionContext context)
	 {
		  var users = administration.CreateChildPermission(AppPermissions.Pages_Administration_Users, L("Users"));
		  users.CreateChildPermission(AppPermissions.Pages_Administration_Users_Create, L("CreatingNewUser"));
		  users.CreateChildPermission(AppPermissions.Pages_Administration_Users_Edit, L("EditingUser"));
		  users.CreateChildPermission(AppPermissions.Pages_Administration_Users_Delete, L("DeletingUser"));
	  }
}  
---------------------------------------------------------------------------------------

 i1Core.Core.Localization.i1Core.i1Core.XML

#we localize all premissions in XML file in key value formate

  <text name="HomePage">Home page</text>
  <text name="AboutUs">About us</text>
  <text name="Administration">Administration</text>
  <text name="Roles">Roles</text>
  
  
************************************************************************************************************************************************  
************************************************************Create NuGet Package****************************************************************

To create NuGet Packge

step 1: Create a .NET Class Library project

Step 2: Implement your code
In the project, add your C# code (e.g., a Logger class with a Log method)

Step 3: Configure project properties

1.Right-click the project in Solution Explorer and select Properties
2.In the Application tab, set the following properties:
-Assembly Name: Your project name (e.g., AppLogger)
-Default namespace: Your namespace (e.g., AppLogger)
-Target Framework: Your chosen framework (e.g., .NET 8.0)
3.In the Packge tab, set following properties:
- title
- Authers "Akash"

#README and licence is required(optional)
Go to project Folder 
-Create Text file and set type as MD and save type is All file
	ex. ReadMe.MD (Markdown)
-Create Text file for license 
	ex. license.txt
	
set the README and license path in properties 	

Package license = Embedded file
Save the project properties

Step 4: Packing
-Rigth click on project-> Pack /
/ this will create newGet file and showing file path on console

Step 5: Publish the package

Register for a NuGet account and obtain an API key
Use the NuGet CLI to push the package to nuget.org: nuget push AppLogger.1.0.0.nupkg <API_KEY>
Replace <API_KEY> with your actual API key
or
push your package on git

That’s it! Your NuGet package is now created and published. 
You can install it in other projects using NuGet Package Manager in Visual Studio or the dotnet CLI.

--------------------------------for install-----------------------------------------------
get the path of the git repo 
-Add git path in tool-> package Manager-> package source
-Browse and install the package


************************************************************************************************************************************************
**********************************************************DB Connection*************************************************************************


Command for connect DB
Scaffold-DbContext "server=DESKTOP-HI1APHJ\SQLEXPRESS; database=Employees; trusted_connection=true; TrustServerCertificate=true;" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models

steps
-we add connection string in appsetting.json-
-we configure this string program.cs by using builder.service.AddDbContext
-we crete seprate class for set DbSet and in that we pass model name, this model will map to Db schema. EF is work as ORM tool where object is map

requied some package to connect Db - Microsoft.EntityFrameworkCore.SqlServer/tool/design

DB Conection
# For update and migrate db we requied - Microsoft.EntityFrameworkCore.tool package       <- requied for Communication with DB
# and to running tool package we requied - Microsoft.EntityFrameworkCore.design package

#query for update database and migration
	-Add-Migration YourMigrationName -Project  wealthmapper.InstrumentEntityFrameworkCore        //Create Table in Project
	-update-database -project wealthmapper.InstrumentEntityFrameworkCore						 // update into Database



---------------------------------------------Program.cs---------------------------------------------

builder.Services.AddDbContext<DataContext>(option =>
{
    option.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));
});

---------------------------------------------appSettings.json---------------------------------------------

"ConnectionStrings": {
  "DefaultConnection": "server=DESKTOP-HI1APHJ\\SQLEXPRESS; database=pokemonreview; trusted_connection=true; TrustServerCertificate=true;"
},

----------------------------------------------MyDbContext------------------------------------------------

 public class DataContext : DbContext/AbpDbContext
 {
     public DataContext (DbContextOptions<DataContext> option):base(option) { }  

     public DbSet<Category> Categories {  get; set; }                                        //make it public so that we can Access Table in code
     public DbSet<Country> Country { get; set; }
     public DbSet<Owner> Owner { get; set; } 
	 
	 //Req for set Promary Key
	  protected override void OnModelCreating(ModelBuilder modelBuilder)
	{
     modelBuilder.Entity<User>()
         .HasKey(u => u.Id); // Specify the primary key
	}
 }
------------------------------------------- --------------------------------------------------------------------------------------


# We use Microsoft.EntityFrameworkCore.SqlServer for several reasons:

SQL Server Compatibility: It allows Entity Framework Core (EF Core) to communicate effectively with Microsoft SQL Server databases, utilizing SQL Server's features and optimizations.

ORM Capabilities: EF Core is an Object-Relational Mapper (ORM) it allow us to work with .NET objects, rather than SQL queries.

LINQ Support: It enables the use of Language Integrated Query (LINQ) to perform queries against the database in a strongly typed way, making code more readable and maintainable.

Migration Support: EF Core supports database migrations, allowing you to evolve your database schema over time as your application changes.

Change Tracking: It provides automatic change tracking, making it easier to manage updates to entities.
---------------------------------------------------------------------------------------------------------------------------------
# We use Microsoft.EntityFrameworkCore.Tools for several important reasons:

Command-Line Interface: It provides a set of command-line tools that facilitate database management tasks directly from the terminal or Package Manager Console, such as creating, updating, and managing migrations.

Migration Management: It simplifies the process of adding, removing, and applying migrations, allowing developers to keep their database schema in sync with the application’s data model.
---------------------------------------------------------------------------------------------------------------------------------
# We use Microsoft.EntityFrameworkCore.design for several important reasons:
Migration Generation: This package enables the creation of migrations from your entity model, allowing you to update your database schema easily as your data model evolves.


************************************************************************PostGreSQL***************************************************************************
Packages:  Npgsql.EntityFrameworkCore.PostgreSQL
		   Microsoft.EntityFrameworkCore.Design
	       Microsoft.EntityFrameworkCore.Tools

steps
-we add connection string in appsetting.json-
-we configure this string program.cs by using builder.service.AddDbContext
-we crete seprate class for set DbSet and in that we pass model name, this model will map to Db schema. EF is work as ORM tool where object is map

---------------------------------------------MyDbContext------------------------------------------------

 public class DataContext : DbContext/AbpDbContext                                             // Db context Come from MicrosoftEntiyFrameworkCOre package
 {
     public DataContext (DbContextOptions<DataContext> option):base(option) { }  

     public DbSet<Category> Categories {  get; set; }                                        //make it public so that we can Access Table in code
     public DbSet<Country> Country { get; set; }
     public DbSet<Owner> Owner { get; set; } 
	 
 }
 ---------------------------------------------Program.cs---------------------------------------------

builder.Services.AddDbContext<DataContext>(option =>
{
    option.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection"));
});

---------------------------------------------appSettings.json---------------------------------------------

"ConnectionStrings": {
 "DefaultConnection":"Server=localhost;Port=5432;Database=University;UserId=postgres;Password=Admin"
},
 
 Add-Migration initialMigration -c MyDbContect -o Data/Migrations
 update-Database
***********************************************************************************************************************************
**********************************************************ABP Framework*********************************************************

ABP Structure

ABP Template(New Version)

Application   -> Api Definition
Application.Shared -> Interface API Definition
Core -> Core Library/Logic of ABP
Core.Shared
EntityFramworkCore -> DB Defination
Migrator -> Migration/Seeding
Web.Core -> Final library package of project
Web.Host -> Executable project 


https://youtu.be/-QiRPa5Xyws?si=mMkV4H058w2Dn3oF

The ABP Project comes with default DDD principal.

Application : - It is also known as Service layer as it will contain the service implementation, in ABP we don't need to create any API controller as this service layer will behave like Api Controller once we inherit it from ApplicationService   
Application.Shared : - All the DTO's will be mapped using Abp Auto Mapper. We need to inherit it from Profile, 
					 - All The interfaces and DTOs are Defined hear and Mapping Logic also.

Core :   - In this layer the database entities and setting are defined. Moreover Dbmigration and seeding is also connected with this layer to start with.
		 - All the common setting and constants are also the part of this layer.

Core.Shared: - This layer is sherd with domain layer.
			 - All the localization stuff, Error Codes or any global configuration are reside in this layer.
EntityFramworkCore : - without this layer we need to configure db seperatly,
					 - This layer is used for Entity frame work configuration and implementation.
					 - All DbContext will be generate here
					 - In Entity Framework Module, we just need to configure the service for Auditing, UOW or Dbcontext option to use database.
					 
Migrator : - This is Console based application, it is used to create all the necessary tables and data seeding to start the project. we just need to give database connection string to start the migration process.
		   - it run first to create table in database
Web.Core : 
Web.Host :  - This layer is the entry point for Api project.
			- All the start configuration for Autofact, swagger and logging are configured here
			- Its our starting point. 
			
			
**********************************************************************************************************************************************
****************************************************************Figma Design Tools************************************************************


Figma :
Figma is a cloud-based design tool that is widely used in software development for creating user interfaces (UI) and user experiences (UX).
#Collaborative Design:- 
	Figma allows multiple users to work on a design simultaneously, similar to how Google Docs works for text documents. This real-time collaboration enables teams to provide instant feedback and make changes on the fly.

#Prototyping:-
	Designers can create interactive prototypes that simulate how a user would interact with an application. This helps stakeholders visualize the final product before development begins.

#Hand-off to Developers:-
	Figma provides features that help streamline the hand-off process to developers. Developers can inspect designs, extract assets, and get CSS code snippets directly from the design files.

Conclusion
Figma plays a crucial role in modern software development by bridging the gap between design and development. Its collaborative features, prototyping capabilities, and integration with other tools make it a valuable asset for teams looking to streamline their design processes and enhance user experiences.


*****************************************************************************************************************************************
**************************************************************Program.cs file Explaination**********************************************

#Create WebApplication Builder

var builder = WebApplication.CreateBuilder();                         

The WebApplication.CreateBuilder() : is used to set up the application builder for a web application. 
									This method initializes a new instance of WebApplicationBuilder, 
									allowing you to configure services, middleware, and other application settings in a fluent manner.


----------------------------------------------------------------------------------------------------------------------------------------------
// Add services to the container.

builder.Services.AddControllers(); 
	Registers the MVC controllers in the dependency injection container.
	
----------------------------------------------------------------------------------------------------------------------------------------------	
builder.Services.AddEndpointsApiExplorer();
	- is used in ASP.NET Core to enable API exploration features, particularly when working with minimal APIs. This feature is useful for generating documentation and providing introspection capabilities for your endpoints.
	- Enables the API exploration feature.
----------------------------------------------------------------------------------------------------------------------------------------------
builder.Services.AddSwaggerGen();
	-Registers Swagger services to generate
----------------------------------------------------------------------------------------------------------------------------------------------
builder.Services.AddSingleton<IOrder, Order>();
	- This line of code registers Order as an implementation of the IOrder interface with the DI container as a singleton.

----------------------------------------------------------------------------------------------------------------------------------------------
#JWT Configuration
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateAudience = true,
            ValidateIssuer = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))

        };
    });
builder.Services.AddAuthorization();

----------------------------------------------------------------------------------------------------------------------------------------------
var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();             //Enables the Swagger middleware.
    app.UseSwaggerUI();           //Configures the Swagger UI, allowing you to visualize the API documentation at runtime. 
}

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();             //Maps attribute-routed controllers. without that it will not find controller it will show 404 error 

app.Run();                        //Starts the application.

***********************************************************************************************************************************************************
*********************************************************NUnit Testing*************************************************************************************
#NUnit Testing
NUnit is a popular testing framework for .NET applications that provides a range of features for creating and executing unit tests.
Basically we use NUnit testing for test class library becouse class library cannot run directly bcz it don't have starting point.

step 1 - create NUnit Test Project

its best for Dotnet 8.0+
all the requied Packages will create automatically

step 2 - all new class 
{
	[TestFixture]
	public class MapperTest
	{
		[Test]
		public void MethodName(Parameters)
		{
		
		}
	}
}
step 3 - add Project reference to NUnit Project


# What is NUnit Testing Framework?
- NUnit is a unit-testing framework for all .Net languages. it has support of .Net Core framework.

# Advantage:
it helps to run the test in Parallel, sequence, and orderd

# Attributes: NUnit uses attributes to define tests, setup, teardown, and other aspects of the test lifecycle.
[Test]: Marks a method as a test method.
[SetUp]: Runs before each test method to prepare the test environment.
[TearDown]: Runs after each test method to clean up.
[TestFixture]: Indicates a class that contains tests.
[TestCase]: Allows parameterized tests with multiple inputs.

# Test Runner: NUnit includes test runners that can execute tests and report results. These can be integrated into IDEs like Visual Studio or run from the command line.
# Parallel Testing: NUnit supports running tests in parallel to improve performance.

#Assertions: NUnit provides a variety of assertion methods to verify conditions in tests.
Assert.AreEqual(expected, actual): Asserts that two values are equal.
Assert.IsTrue(condition): Asserts that a condition is true.
Assert.IsFalse(condition): Asserts that a condition is false.
Assert.Throws<T>(action): Asserts that an action throws a specific exception.

********************************************************************************************************************************************************
**************************************************************Environment Variables*********************************************************************
#Environment Variables

Environment variables are used to store configuration settings that vary between different environments, such as development, testing, staging, and production. 
In a Web API, environment variables can be used to customize settings, secrets, and dependencies specific to each environment. Here’s a concise overview:

Why use environment variables?
Separation of concerns: Keep sensitive data, such as database connections or API keys, separate from your code.
Easy configuration: Update environment variables without modifying code.