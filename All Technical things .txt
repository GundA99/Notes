Technical things all
Difference jira taiga

1.  JWT -jwt & Swagger setting 
2.  Annotations
3.  Role and Permission settings
4.  Create NuGet Package and install
5.  Db Connection 
6.  ABP Framwork , appsettings vs launchSetting
7.  Figma tool
8.  Program.cs file explaination
9.  NUnit Testing
10. Environmentveriables
11. Difference SQL vs PostgreSQL
12. Logger
13. Difference between .Net and Asp.Net
14. IHttpContextAccessor
15. New Features in .NET 8
16. Web.config file in ASP .NET and Apache Guacamole, Windows IIS Deployment 
17. How to Use Joins
18. Rest Call
19. Swagger Documentation
20. Store Procedure
21. IConfiguration
22. Cors Policy
23. Send Mail Functionality 
24. Azure
25. RDLC Report
**********************************************************************1************************************************************
**********************************************************JWT Token Authentication*************************************************

A JWT (JSON Web Token) typically consists of three parts separated by dots (.).
# Header: 
This part typically consists of two parts: the type of token (which is JWT) and the signing algorithm being used (such as HMAC SHA256 or RSA). 
For example, a header might look like this:
{
  "alg": "HS256",
  "typ": "JWT"
}
-----------------------------------------------------------
# Payload: 
This part contains the claims. Claims are statements about an entity (typically the user) and additional data.
There are three types of claims: registered, public, and private claims.
For example:
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,                ----role
  "Email": "abc"
}

-------------------------Extra Info-----------------------------------
Registered Claims: 
These are predefined claims which are not mandatory but recommended to provide a set of useful, interoperable claims. Some common registered claims include:

iss (issuer): Identifies the principal that issued the JWT.
sub (subject): Identifies the subject of the JWT.
aud (audience): Identifies the recipients that the JWT is intended for.
exp (expiration time): Specifies the expiration time after which the JWT should not be accepted.
nbf (not before): Specifies the time before which the JWT must not be accepted for processing.
iat (issued at): Specifies the time at which the JWT was issued.
jti (JWT ID): Provides a unique identifier for the JWT.
{
  "iss": "issuer",
  "sub": "subject",
  "aud": "audience",
  "exp": 1625939622,
  "nbf": 1625938022,
  "iat": 1625938022,
  "jti": "id123456"
}
----------------------------------------------
Public Claims:
These are custom claims that are defined by users and application developers. They should be defined in a way that they do not clash with registered claims.
Example:
{
  "name": "John Doe",
  "role": "admin"
}
-----------------------------------------------
Private Claims: 
These are custom claims that are agreed upon between parties that use JWTs. They are neither registered nor public claims. 
Example:
{
  "custom_data": {
    "key1": "value1",
    "key2": "value2"
  }
}
-----------------------------------------------
what is Claims
In the context of authentication and authorization using JWT (JSON Web Token), claims refer to the pieces of information asserted about a subject (typically a user) within the token. 
Claims are statements about the subject that provide information such as identity, roles, permissions, and other attributes relevant to the application's security and functionality.

----------------------------------------------------------------------
# Signature: 
To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.

xxxxxxxxxx.yyyyyyyyyy.zzzzzzzzzz

 xxxxxxxxxx is the base64url encoded header
 yyyyyyyyyy is the base64url encoded payload
 zzzzzzzzzz is the signature
#Note:
	for token Creation we need SymmetricSecurityKey its used when we verify token, for that we use random string then Sign this key in signingCredentials with algorithm This algorithm we can see in Header part.
	then we add claims. claim basically key value pairs.  
********************************************************Implemtation****************************************************************
JWT
# Download Microsoft.AspNetCore.Authentication.JwtBearer package.
	-Microsoft.AspNetCore.Authentication.JwtBearer: Provides the middleware that integrates JWT token authentication into ASP.NET Core applications, 
													handling the authentication process automatically during the request lifecycle.
# BCrypt.Net-Next -package for encrypt and deceypt password

	            u.Password =  BCrypt.Net.BCrypt.HashPassword(user.Password);          abs->asdfghj
                var pass = BCrypt.Net.BCrypt.Verify(user.Password, u.Password);        it check password compair and return boolean value.


 public string CreateToken(User user)
 {
     List<Claim> claims = new List<Claim>
	 {
		 new Claim(ClaimTypes.Name, user.UserName),
		 new Claim(JwtRegisteredClaimNames.Sub,iconfig["Jwt:Subject"]),
         new Claim(JwtRegisteredClaimNames.Jti,Guid.NewGuid().ToString()),
	 };

     var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(iconfig["Jwt:Key"]));   //1 
     var signIn = new SigningCredentials(key, SecurityAlgorithms.HmacSha512);          //2 
     var token = new JwtSecurityToken(

         iconfig["Jwt:Issuer"],                 
         iconfig["Jwt:Audience"],
         claims,
         expires: DateTime.UtcNow.AddMinutes(60),
         signingCredentials: signIn
         );                   

// token = {{"alg":"HS512","typ":"JWT"}.{"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name":"akash","sub":"JwtSubject","jti":"50058aea-7287-4695-b268-83397a720482","exp":1726913435,"iss":"JwtIssuer","aud":"JwtAudience"}}		 


     string tokenValue = new JwtSecurityTokenHandler().WriteToken(token);   //3

     return tokenValue;
 }
 
// tokenValue = "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9
				.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWthc2giLCJzdWIiOiJKd3RTdWJqZWN0IiwianRpIjoiNTAwNThhZWEtNzI4Ny00Njk1LWIyNjgtODMzOTdhNzIwNDgyIiwiZXhwIjoxNzI2OTEzNDM1LCJpciLCJhdWQiOiJKd3RBdWRpZW5jZSJ9
				.28gIsVUE2jPlxYshTW55a4_97So3Nwm5CPJYg9mKZczBlVK6yx28GTMmpbeDsl10eBPbHWDP2t8ZRUFcakbj8g"
  
1.
SymmetricSecurityKey: which will be used to sign and validate the JWT tokens. Symmetric keys mean the same key is used for both signing (creating the token) and verifying (validating the token).
2.
SigningCredentials: It encapsulates the information needed to sign the token, including the security key and the algorithm used for signing. 
3.
JwtSecurityTokenHandler:
This is a class from the System.IdentityModel.Tokens.Jwt namespace. It provides methods for creating, validating, and handling JWT tokens.
.WriteToken(token): This method takes a JwtSecurityToken object (referred to here as token) and converts it into a string format. This string representation is what you will send to the client as the actual JWT.



# What is the Issuer?
Issuer: The issuer is a claim that indicates who issued the JWT. It’s often used to help verify the authenticity of the token. When the token is created, the issuer value is included in the claims. When validating the token, you can check if the issuer matches the expected value.

#What is the Audience?
Audience: The audience claim (aud) specifies the intended recipient(s) of the token. It indicates who the token is meant for. This is useful for ensuring that the token is only processed by the intended consumer(s), adding an extra layer of security.

- we use [Authorize] Key word to secure api 
	if we not add token then it will give 401 unAuthorized
Note: we need same Issuer, Audience, and Key to verify
-------------------------------------------------------------Program.cs-----------------------------------------------------------------


builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateAudience = true,
            ValidateIssuer = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))

        };
    });
	
	
// Add authorization
builder.Services.AddAuthorization();

// Use authentication
app.UseAuthentication();

app.UseAuthorization();


	
-----------------------------------appsetting.json----------------------------------------
  "Jwt": {
    "Key": "asdfghjhgfdsdfghjkjhgfdsghjhgfdsdfghjjhg1234567890sdfdsasdfghjhgfdsdfghjkjhgfdsghjhgfdsdfghjjhg1234567890sdfds",
    "Issuer": "JwtIssuer",                      //who create token
    "Audience": "JwtAudience",					// for whom Crete token
    "Subject": "JwtSubject"
  }	
  -------------------------------------------to enable functionality where we pass token in swagger--------------------------------------------------------------
    
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "My API", Version = "v1" });     //Show in swagger 

    // Add JWT Bearer authentication to Swagger
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        In = ParameterLocation.Header,                                            //Where the token should be provided (in the header).
        Description = "Please enter a valid token",								  //Description: A brief guide on how to use the token.
        Name = "Authorization",													  //Name: The name of the header to include (in this case, "Authorization")
        Type = SecuritySchemeType.ApiKey,										  //Type: Specifies the scheme type (ApiKey for Bearer tokens).
        Scheme = "bearer",														  //Scheme: Indicates that it's a bearer scheme.
        BearerFormat="Jwt"														  //BearerFormat: Indicates the format of the token (JWT).
    });

    c.AddSecurityRequirement(new OpenApiSecurityRequirement                       //This section specifies that the defined Bearer token scheme is required for all API endpoints. 
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            new string[] {}
        }
    });
});

-----------------------------------------------------------Steps for add swagger in project-----------------------------------------------------------
1. install package -> Swashbuckle.AspNetCore
2. Add code -> program.cs -> 	builder.Services.AddEndpointsApiExplorer();
								builder.Service.AddSwaggerGen();
								App.UseSwaggerUI(options =>
								{
									options.SwaggerEndpoint(https://localhost:44301/) + _appConfiguration["App:SwaggerEndPoint"], "WealthMapper.Order V1");
								}); //URL: /swagger
								app.UseSwaggerUI();
								
								
*******************************************************************2*****************************************************************************								
*************************************************************Annotations************************************************************************

Annotations in ASP .Net core

[Required] : Specifies that a data field must be filled out.

[StringLength] : Sets the maximum length of a string field.

     [StringLength(100)]
     public string Name { get; set; }

[Range] : Validates that a numeric field falls within a specified range.
 
    [Range(1, 100)]
    public int Quantity { get; set; }
	
[EmailAddress] : Validates that a field contains a valid email address
	
	[EmailAddress]
    public string Email { get; set; }

[Compare] : Compares two properties to ensure they match, often used for password confirmation.
 
	[Required]
    public string Password { get; set; }

    [Compare("Password")]
    public string ConfirmPassword { get; set; }
	
[RegularExpression] : Validates that a field matches a specified regular expression pattern.

	 [RegularExpression(@"^[A-Z]+[a-zA-Z''-'\s]*$")]
    public string ProductName { get; set; }

[DataType] : Specifies the type of data for a field, which can affect how it's rendered in UI

	[DataType(DataType.Date)]
    public DateTime BirthDate { get; set; }
	
**************************************************************3**********************************************************************************
****************************************************Role & Permission***************************************************************************

Role and Permission Managment

i1Core.Core.Sheard.Authorization.
AppPermissions
#we create All permissions 
public static class AppPermissions
{
	// Customer Permissions
	 public const string Pages_Customer = "Pages.Customer";
	 public const string Pages_Customer_Dashboard = "Pages.Customer.Dashboard";
	 public const string Pages_Customer_Contract = "Pages.Customer.Contract";
	 public const string Pages_Customer_Portfolio = "Pages.Customer.Portfolio";
	 public const string Pages_Customer_Suitability = "Pages.Customer.Suitability";
 }
---------------------------------------------------------------------------------------

i1Core.Core.Authorization.
AppAuthorizationProvider

#we Create Object and by using that we create child permissions

 public class AppAuthorizationProvider : AuthorizationProvider
 {
	 public override void SetPermissions(IPermissionDefinitionContext context)
	 {
		  var users = administration.CreateChildPermission(AppPermissions.Pages_Administration_Users, L("Users"));
		  users.CreateChildPermission(AppPermissions.Pages_Administration_Users_Create, L("CreatingNewUser"));
		  users.CreateChildPermission(AppPermissions.Pages_Administration_Users_Edit, L("EditingUser"));
		  users.CreateChildPermission(AppPermissions.Pages_Administration_Users_Delete, L("DeletingUser"));
	  }
}  
---------------------------------------------------------------------------------------

 i1Core.Core.Localization.i1Core.i1Core.XML

#we localize all premissions in XML file in key value formate

  <text name="HomePage">Home page</text>
  <text name="AboutUs">About us</text>
  <text name="Administration">Administration</text>
  <text name="Roles">Roles</text>
  
  
**********************************************************************4**************************************************************************  
************************************************************Create NuGet Package****************************************************************

To create NuGet Packge

step 1: Create a .NET Class Library project

Step 2: Implement your code
In the project, add your C# code (e.g., a Logger class with a Log method)

Step 3: Configure project properties

1.Right-click the project in Solution Explorer and select Properties
2.In the Application tab, set the following properties:
-Assembly Name: Your project name (e.g., AppLogger)
-Default namespace: Your namespace (e.g., AppLogger)
-Target Framework: Your chosen framework (e.g., .NET 8.0)
3.In the Packge tab, set following properties:
- title
- Authers "Akash"

#README and licence is required(optional)
Go to project Folder 
-Create Text file and set type as MD and save type is All file
	ex. ReadMe.MD (Markdown)
-Create Text file for license 
	ex. license.txt
	
set the README and license path in properties 	

Package license = Embedded file
Save the project properties

Step 4: Packing
-Rigth click on project-> Pack /
/ this will create newGet file and showing file path on console

Step 5: Publish the package

Register for a NuGet account and obtain an API key
Use the NuGet CLI to push the package to nuget.org: nuget push AppLogger.1.0.0.nupkg <API_KEY>
Replace <API_KEY> with your actual API key
or
push your package on git

That’s it! Your NuGet package is now created and published. 
You can install it in other projects using NuGet Package Manager in Visual Studio or the dotnet CLI.

--------------------------------for install-----------------------------------------------
get the path of the git repo 
-Add git path in tool-> package Manager-> package source
-Browse and install the package


*******************************************************************5*****************************************************************************
**********************************************************DB Connection*************************************************************************

-Command for connect DB
Scaffold-DbContext "server=DESKTOP-HI1APHJ\SQLEXPRESS; database=Employees; trusted_connection=true; TrustServerCertificate=true;" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models

-Commands if we Using More Than one Db 
Update-Database -Project wealthmapper.InstrumentEntityFrameworkCore -Context MyDbContext
Add-Migration YourMigrationName -Project wealthmapper.InstrumentEntityFrameworkCore -Context MyDbContext


steps
-we add connection string in appsetting.json-
-we configure this string program.cs by using builder.service.AddDbContext
-we crete seprate class for set DbSet and in that we pass model name, this model will map to Db schema. EF is work as ORM tool where object is map

requied some package to connect Db - Microsoft.EntityFrameworkCore.SqlServer/tool/design

DB Conection
# For update and migrate db we requied - Microsoft.EntityFrameworkCore.tool package       <- requied for Communication with DB
# and to running tool package we requied - Microsoft.EntityFrameworkCore.design package

#query for update database and migration
	-Add-Migration YourMigrationName -Project  wealthmapper.InstrumentEntityFrameworkCore        //Create Table in Project
	-update-database -project wealthmapper.InstrumentEntityFrameworkCore						 // update into Database



---------------------------------------------Program.cs---------------------------------------------

builder.Services.AddDbContext<DataContext>(option =>
{
    option.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));
});

---------------------------------------------appSettings.json---------------------------------------------

"ConnectionStrings": {
  "DefaultConnection": "server=DESKTOP-HI1APHJ\\SQLEXPRESS; database=pokemonreview; trusted_connection=true; TrustServerCertificate=true;"
},

----------------------------------------------MyDbContext------------------------------------------------

 public class DataContext : DbContext/AbpDbContext
 {
     public DataContext (DbContextOptions<DataContext> option):base(option) { }  

     public DbSet<Category> Categories {  get; set; }                                        //make it public so that we can Access Table in code
     public DbSet<Country> Country { get; set; }
     public DbSet<Owner> Owner { get; set; } 
	 
	 //Req for set Promary Key
	  protected override void OnModelCreating(ModelBuilder modelBuilder)
	{
     modelBuilder.Entity<User>()
         .HasKey(u => u.Id); // Specify the primary key
	}
 }
------------------------------------------- --------------------------------------------------------------------------------------


# We use Microsoft.EntityFrameworkCore.SqlServer for several reasons:

SQL Server Compatibility: It allows Entity Framework Core (EF Core) to communicate effectively with Microsoft SQL Server databases, utilizing SQL Server's features and optimizations.

ORM Capabilities: EF Core is an Object-Relational Mapper (ORM) it allow us to work with .NET objects, rather than SQL queries.

LINQ Support: It enables the use of Language Integrated Query (LINQ) to perform queries against the database in a strongly typed way, making code more readable and maintainable.

Migration Support: EF Core supports database migrations, allowing you to evolve your database schema over time as your application changes.

Change Tracking: It provides automatic change tracking, making it easier to manage updates to entities.
---------------------------------------------------------------------------------------------------------------------------------
# We use Microsoft.EntityFrameworkCore.Tools for several important reasons:

Command-Line Interface: It provides a set of command-line tools that facilitate database management tasks directly from the terminal or Package Manager Console, such as creating, updating, and managing migrations.

Migration Management: It simplifies the process of adding, removing, and applying migrations, allowing developers to keep their database schema in sync with the application’s data model.
---------------------------------------------------------------------------------------------------------------------------------
# We use Microsoft.EntityFrameworkCore.design for several important reasons:
Migration Generation: This package enables the creation of migrations from your entity model, allowing you to update your database schema easily as your data model evolves.

********************************************PostGreSQL***************************************************************************
Packages:  Npgsql.EntityFrameworkCore.PostgreSQL
		   Microsoft.EntityFrameworkCore.Design
	       Microsoft.EntityFrameworkCore.Tools

steps
-we add connection string in appsetting.json-
-we configure this string program.cs by using builder.service.AddDbContext
-we crete seprate class for set DbSet and in that we pass model name, this model will map to Db schema. EF is work as ORM tool where object is map

---------------------------------------------MyDbContext------------------------------------------------

 public class DataContext : DbContext/AbpDbContext                                             // Db context Come from MicrosoftEntiyFrameworkCOre package
 {
     public DataContext (DbContextOptions<DataContext> option):base(option) { }  

     public DbSet<Category> Categories {  get; set; }                                        //make it public so that we can Access Table in code
     public DbSet<Country> Country { get; set; }
     public DbSet<Owner> Owner { get; set; } 
	 
 }
 ---------------------------------------------Program.cs---------------------------------------------

builder.Services.AddDbContext<DataContext>(option =>
{
    option.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection"));
});

---------------------------------------------appSettings.json---------------------------------------------

"ConnectionStrings": {
 "DefaultConnection":"Server=localhost;Port=5432;Database=University;UserId=postgres;Password=Admin"
},
 
 Add-Migration initialMigration -c MyDbContect -o Data/Migrations
 update-Database
******************************************************************6*****************************************************************
**********************************************************ABP Framework*********************************************************

ABP Structure
abp net zero framework - paid framework
-Advance level features

abp free
-Basic feature

ABP Template(New Version)

Application   -> Api Definition
Application.Shared -> Interface API Definition
Core -> Core Library/Logic of ABP
Core.Shared
EntityFramworkCore -> DB Defination
Migrator -> Migration/Seeding
Web.Core -> Final library package of project
Web.Host -> Executable project 


https://youtu.be/-QiRPa5Xyws?si=mMkV4H058w2Dn3oF

The ABP Project comes with default DDD principal.

Application : - It is also known as Service layer as it will contain the service implementation, in ABP we don't need to create any API controller as this service layer will behave like Api Controller once we inherit it from ApplicationService   
Application.Shared : - All the DTO's will be mapped using Abp Auto Mapper. We need to inherit it from Profile, 
					 - All The interfaces and DTOs are Defined hear and Mapping Logic also.

Core :   - In this layer the database entities and setting are defined. Moreover Dbmigration and seeding is also connected with this layer to start with.
		 - All the common setting and constants are also the part of this layer.

Core.Shared: - This layer is sherd with domain layer.
			 - All the localization stuff, Error Codes or any global configuration are reside in this layer.
EntityFramworkCore : - without this layer we need to configure db seperatly,
					 - This layer is used for Entity frame work configuration and implementation.
					 - All DbContext will be generate here
					 - In Entity Framework Module, we just need to configure the service for Auditing, UOW or Dbcontext option to use database.
					 
Migrator : - This is Console based application, it is used to create all the necessary tables and data seeding to start the project. we just need to give database connection string to start the migration process.
		   - it run first to create table in database
Web.Core : 
Web.Host :  - This layer is the entry point for Api project.
			- All the start configuration for Autofact, swagger and logging are configured here
			- Its our starting point. 
			
ABP is a open source web application framework to create mobile and web application based on asp .net core it provide infrastructure for interprice level software
Command for create solution-
	     abp new <YourProjectName>
Notes:	
Modularity: ABP allows you to build applications in a modular way, making it easier to manage dependencies and share functionality across different parts of the application.

User and Role Management: It includes a comprehensive user and role management system, simplifying authentication and authorization.

Localization and Globalization: The framework supports multiple languages and cultures, making it easier to create applications that can cater to a global audience.

API Development: ABP simplifies the creation of RESTful APIs, making it easier to expose application functionality to front-end applications or third-party services.

UI Frameworks: ABP integrates well with various front-end frameworks, such as Angular and React, allowing for modern web application development.

Dependency Injection: It uses built-in dependency injection, promoting a loosely coupled design.

"AbpZeroLicenseCode": "00Rz+spUiUf//knTuf2oCR1Q==ab6750f9b8237b730391ebb3d1a96323" : in the appsettings.json file is related to licensing in applications built with the ABP Framework (Asp.Net Boilerplate). 
Specifically, it serves the following purposes:
ABP Zero is a commercial application framework built on top of ABP, which provides features like user and role management, multi-tenancy, and more.
The "AbpZeroLicenseCode" key holds the license code required for the application to operate with ABP Zero's commercial features. Without a valid license, the application may be limited in functionality or not work as expected.
-----------------------------------------------------------
#appsettings.json		
Used for application-level configuration settings.
Contain Environment veriables,DB ConnectionStrings, AbpZeroLicenseCode, JwtBearer issuer, Audience, server related configuration 

#launchSetting.json
Used for development and debugging environment configuration.

In ASP.NET Core, the launchSettings.json file is used to configure how the application runs during development. It contains settings like:
-Profiles: Defines different ways to launch the app, such as using IIS Express or Kestrel, Http, Https.
-Environment Variables: Sets environment variables like ASPNETCORE_ENVIRONMENT (e.g., "Development").
-Application URL: Specifies the URLs (e.g., http://localhost:5000) the app should listen on.
-Authentication Settings: Configures authentication methods (e.g., anonymous or Windows authentication).
		Windows Authentication allows users to authenticate using their Windows credentials
		allows users to access the application without providing any credentials.
		"windowsAuthentication": false,
		"anonymousAuthentication": true,
-AppsettingsFilePath: If we using centralized AppSetting the we add path here

#If we want to Access Base Schemes table 

Abp.Domain.Repositories.IRepository<TEntity, TPrimaryKey>
ex
using Abp.Domain.Repositories;

   private readonly IRepository<User, long> _userRepository;  <- inject dependacy


*************************************************************************7*********************************************************************
****************************************************************Figma Design Tools************************************************************


Figma :
Figma is a cloud-based design tool that is widely used in software development for creating user interfaces (UI) and user experiences (UX).
#Collaborative Design:- 
	Figma allows multiple users to work on a design simultaneously, similar to how Google Docs works for text documents. This real-time collaboration enables teams to provide instant feedback and make changes on the fly.

#Prototyping:-
	Designers can create interactive prototypes that simulate how a user would interact with an application. This helps stakeholders visualize the final product before development begins.

#Hand-off to Developers:-
	Figma provides features that help streamline the hand-off process to developers. Developers can inspect designs, extract assets, and get CSS code snippets directly from the design files.

Conclusion
Figma plays a crucial role in modern software development by bridging the gap between design and development. Its collaborative features, prototyping capabilities, and integration with other tools make it a valuable asset for teams looking to streamline their design processes and enhance user experiences.


***************************************************************************8**************************************************************
**************************************************************Program.cs file Explaination**********************************************

#Create WebApplication Builder

var builder = WebApplication.CreateBuilder();                         

The WebApplication.CreateBuilder() : is used to set up the application builder for a web application. 
									This method initializes a new instance of WebApplicationBuilder, 
									allowing you to configure services, middleware, and other application settings in a fluent manner.


----------------------------------------------------------------------------------------------------------------------------------------------
// Add services to the container.

builder.Services.AddControllers(); 
	Registers the MVC controllers in the dependency injection container.
	
----------------------------------------------------------------------------------------------------------------------------------------------	
builder.Services.AddEndpointsApiExplorer();
	- is used in ASP.NET Core to enable API exploration features, particularly when working with minimal APIs. This feature is useful for generating documentation and providing introspection capabilities for your endpoints.
	- Enables the API exploration feature.
----------------------------------------------------------------------------------------------------------------------------------------------
builder.Services.AddSwaggerGen();
	-Registers Swagger services to generate
----------------------------------------------------------------------------------------------------------------------------------------------
builder.Services.AddSingleton<IOrder, Order>();
	- This line of code registers Order as an implementation of the IOrder interface with the DI container as a singleton.

----------------------------------------------------------------------------------------------------------------------------------------------
#JWT Configuration
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateAudience = true,
            ValidateIssuer = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))

        };
    });
builder.Services.AddAuthorization();

----------------------------------------------------------------------------------------------------------------------------------------------
var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();             //Enables the Swagger middleware.
    app.UseSwaggerUI();           //Configures the Swagger UI, allowing you to visualize the API documentation at runtime. 
}

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();             //Maps attribute-routed controllers. without that it will not find controller it will show 404 error 

app.Run();                        //Starts the application.

*****************************************************************9******************************************************************************************
*********************************************************NUnit Testing*************************************************************************************
#NUnit Testing
NUnit is a popular testing framework for .NET applications that provides a range of features for creating and executing unit tests.
Basically we use NUnit testing for test class library becouse class library cannot run directly bcz it don't have starting point.

step 1 - create NUnit Test Project

its best for Dotnet 8.0+
all the requied Packages will create automatically

step 2 - all new class 
{
	[TestFixture]
	public class MapperTest
	{
		[Test]
		public void MethodName(Parameters)
		{
		
		}
	}
}
step 3 - add Project reference to NUnit Project


# What is NUnit Testing Framework?
- NUnit is a unit-testing framework for all .Net languages. it has support of .Net Core framework.

# Advantage:
it helps to run the test in Parallel, sequence, and orderd

# Attributes: NUnit uses attributes to define tests, setup, teardown, and other aspects of the test lifecycle.
[Test]: Marks a method as a test method.
[SetUp]: Runs before each test method to prepare the test environment.
[TearDown]: Runs after each test method to clean up.
[TestFixture]: Indicates a class that contains tests.
[TestCase]: Allows parameterized tests with multiple inputs.

# Test Runner: NUnit includes test runners that can execute tests and report results. These can be integrated into IDEs like Visual Studio or run from the command line.
# Parallel Testing: NUnit supports running tests in parallel to improve performance.

#Assertions: NUnit provides a variety of assertion methods to verify conditions in tests.
Assert.AreEqual(expected, actual): Asserts that two values are equal.
Assert.IsTrue(condition): Asserts that a condition is true.
Assert.IsFalse(condition): Asserts that a condition is false.
Assert.Throws<T>(action): Asserts that an action throws a specific exception.

************************************************************************10********************************************************************************
**************************************************************Environment Variables*********************************************************************
#Environment Variables

Environment variables are used to store configuration settings that vary between different environments, such as development, testing, staging, and production. 
In a Web API, environment variables can be used to customize settings, secrets, and dependencies specific to each environment. Here’s a concise overview:

Why use environment variables?
Separation of concerns: Keep sensitive data, such as database connections or API keys, separate from your code.
Easy configuration: Update environment variables without modifying code.

************************************************************************11********************************************************************************
**************************************************************Sql vs PostGreSql*********************************************************************

Major Difference Between Sql Server and PostGreSql
SQL Server-----vs--------PostgreSQL

1.Relational database management system ----   Object-relational database management system
2.Commercial product from Microsoft  ------  Open source (completely free) 
3.Primarily designed for Windows, but recent versions also support Linux. ------ can run on various operating systems including Windows, Linux, and macOS.

#Sql --> PostgreSQL 
nvarchar(max)  == Text
datetime2(7) == TIMESTAMP(7)
bit == BOOLEAN
IDENTITY(1,1) == PRIMARY KEY
uniqueidentifier == UUID 
tinyint == SMALLINT 
varbinary == BYTEA
************************************************************************12**********************************************************************
**********************************************************************Logger********************************************************************

The ILogger interface is designed to provide a simple logging abstraction for .NET applications, 
allowing developers to log messages from their code in a structured manner. It abstracts away the specific logging implementation, 
which could be based on various logging providers such as Console, Debug, EventSource, or third-party logging frameworks like Serilog or NLog. 

# Key Features and Usage
-Logging Levels: ILogger supports different logging levels such as Information, Warning, Error, Debug, etc. 
This helps in categorizing the severity of the logged messages.
-Log Message Formatting: It provides methods like LogInformation, LogWarning, LogError, etc., 
which accept a message string and optionally some parameters to be formatted into the message.
--------------------------------------------------------------------------
Syntax

logger.LogInformation(5,"The database is ready!");
Above code result in console -

info: DB Initializer[5]
      The database is ready!
-------------------------------------------------------------------------
Logger Composition: In .NET Core applications, you typically inject ILogger<T> into your classes using dependency injection. 
This strongly-typed logger (ILogger<T>) allows you to easily categorize logs by the type where logging occurs, making it easier to filter and understand logs.

using Microsoft.Extensions.Logging;

public class MyService
{
    private readonly ILogger<MyService> _logger;    <-- Default logger provided by microsoft

    public MyService(ILogger<MyService> logger)
    {
        _logger = logger;
    }

    public void DoWork()
    {
        _logger.LogInformation("Doing some work...");
		_logger.LogWarning("if there are some warnings")
        try
        {
            // Some operation that might throw an exception
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An error occurred while doing work.");
        }
    }
}

-------------------------------------------------------------------------
for see logs in json formate in console
add code in program.cs

builder.Logging.AddJsonConsole(options => 
{
	options.JsonWriterOptions = new()
	{
	    Indented = true
	};
});

----------------------------------------------------------------------------------------
There Are multiple logging providers 
1.JSNLog, 
2.Log4Net,
3.NLog


Log4Net
Requred Package Install - Microsoft.Extensions.Logging.Log4Net.AspNetCore
-----------------------------------------------------------
program.cs
Builder.Logging.AddLog4Net();
-----------------------------------------------------------
Add a log4net.config File(Rigth Click->add New Item-> select Web Configuration File-> add ) with the content
	
	<?xml version="1.0" encoding="utf-8"?>
	<log4net>
		<appender name="DebugAppender" type="log4net.Appender.DebugAppender">  
			<layout type="log4net.Layout.PatternLayout>
				<conversionPattern value="%data [%thread] %-5level %logger - %message%newline" />
			</layout>
		</appender>
		<appender name="ConsoleAppender" type="log4net.Appender.ConsoleAppender">         <-- If we want to see log in console window then we use this appender
			<layout type="log4net.Layout.PatternLayout>
				<conversionPattern value="%data [%thread] %-5level %logger - %message%newline" />
			</layout>
		</appender>
		<root>
			<level value="All">
			<appender-ref ref="DebugAppender" />
			<appender-ref ref="ConsoleAppender" />           <--- Configure appender root
		<root>
	<log4net>	
	
Configure LogLevel in log4Net.config file	
	- Log Levels for Log4Net =>	All, DEBUG,Trace, INFO, WARN,ERROR,FATAL  
-----------------------------------------------------------
add configure Development Level Configuration in appsettings.Development.json
{
	"Logging":
	{
		"LogLevel":{
			"Default": "Trace",
			}
	}		
}
-----------------------------------------------------------
*) when we want to use File Provider add below Configuration

		<appender name="RollingFile" type="log4net.Appender.RollingFileAppender">         <-- If we want to see log in console window then we use this appender
			<file value="{Projectpath}.Logs\log.txt"/>
			<rollingStyle value="Once">      <-- Rolling Style
			------------or--------------
			<rollingStyle value="Size"/>      <-- If rolling Style size
			<maximumFileSize value="1kb"/>    <-- Default size 10mb if not provide size
			<maxSizeRollbackups value="5"/>   <-- it keep that much Backup files 
			
			<layout type="log4net.Layout.PatternLayout>
				<conversionPattern value="%data [%thread] %-5level %logger - %message%newline" />
			</layout>
		</appender>
		<root>
			<level value="All">
 			<appender-ref ref="RollingFile" />           <--- Configure appender root
		<root>
		
this will log the logs in the log file
# Rolling style of Log4Net
once = Roll Files once per program execution
size = Roll file based only on the size of the file
Date = Roll file based only on the date
Composite = Roll file based on both the size and date of the file.

- Console and Debug window are default logging windows
builder.logging.AddDebug();  <- if we want only Debug window
builder.logging.AddConsole(); <- if we want only Console window


**************************************************************13**********************************************************************
*************************************************Difference between .Net and Asp.Net************************************************************

.Net: only work on window.

ASP .Net Core : 
-support cross platform like windows,linux.
-Support microservices architecture
-performance is faster.
-open source 
-Container support,we can build application and run on docker 	
-SP.NET is a part of the .NET framework specifically designed for building web applications and services.
In summary, .NET is the overall framework for various types of applications, while ASP.NET is specifically focused on web application development.

Why ASP.Net Core?
Open source - anyone can use until it will Enterprise level
Cross Platform
CLI Support 
- .Net Core allow development on Windows, MacOs and linux
- We can use various IDE's, Including Visual Studio Code.


********************************************************************14*****************************************************************
**************************************************************IHttpContextAccessor*********************************************************
Program.cs

builder.Services.AddHttpContextAccessor(); // Ensure HttpContextAccessor is available in IInstrumentServices
builder.Services.AddScoped<IInstrumentServices, InstrumentService>();

InstrumentService.cs
private readonly IHttpContextAccessor _httpContextAccessor;
public instrumentController(IHttpContextAccessor httpContextAccessor)
{
    _httpContextAccessor = httpContextAccessor;
}
string result = _httpContextAccessor.HttpContext.Request.Headers["Authorization"];
********************************************************************15*****************************************************************
*********************************************************New Features in .NET 8******************************************************
Minimal API Improvements:
Results Enhancements: New methods for returning responses (Results.Ok(), Results.NotFound(), etc.) have been optimized for better performance and flexibility.

Improved Performance
- Faster Startups & Lower Memory Usage: .NET 8 introduces even better performance improvements, including lower startup times and better memory usage for both large and small applications.
- JIT Optimizations: Just-In-Time (JIT) compiler improvements help to optimize runtime performance, making applications faster, especially in high-load scenarios.
- Garbage Collection Improvements: The garbage collector has been optimized to minimize latency and improve throughput in high-performance applications.

Authorization and Authentication Enhancements
-IdentityServer Integration: ASP.NET Core 8 has better out-of-the-box integration with IdentityServer for OAuth2 and OpenID Connect flows, which makes handling user authentication and authorization in distributed systems easier.

OpenAPI and Swagger Enhancements
-ASP.NET Core 8 comes with an updated version of Swagger UI for automatic API documentation. The SwaggerGen and SwaggerUI packages are more tightly integrated into the framework.
-API Versioning: Support for API versioning is better than ever. You can specify versions in routes and produce versioned documentation automatically with the help of Swashbuckle or other similar tools.

.NET 8 introduces several features that make it easier to build cloud-native applications, including:
-Docker support: Enhanced integration with containerized applications, offering improvements in performance, ease of use, and support for the latest Docker features.

********************************************************************16*****************************************************************
*********************************************************Web.config file in ASP .NET******************************************************

#Apache Guacamole
Apache Guacamole is a remote desktop gateway that allows users to access remote systems and desktops over the web.
its a FTP(File transfer protocol) Which is used to get file from one server to remote server and vise versa
------------------------------------
#Web.config file in ASP .NET
-In ASP.NET 8 (or any version of ASP.NET Core), the web.config file is generally not required in most cases, especially when you're building modern web applications using ASP.NET Core. 
-This file was traditionally used in ASP.NET Framework (the older version of ASP.NET), but its role in ASP.NET Core has shifted somewhat.
-However, the web.config file is still relevant in certain scenarios, particularly for hosting ASP.NET Core applications on IIS (Internet Information Services), which is commonly used for Windows-based deployments.

-------------------------------------
Windows IIS Deployement
1.Connect server VPN (getting code on mobile)
2.access server by server link 
3.There are Remote Access option by using VM var we can virtually access the server
4.then we use Apache Guacamole tool for upload new build.
5.new build copy into D:/Install folder
6.open D:/SDB/serviceName/ take backup and past into D:/Backup folder. bcz if we want to revet that time it requird.
7.Stop service from application pool.
8.replace build. 
9.Then start service. 
********************************************************************17*****************************************************************
*******************************************************************Join******************************************************
 
 var allProductData = await _productGroupTestVersions.GetAll().Where(y => !y.IsDeleted).OrderByDescending(x => x.UpdatedOn) //.OrderBy(x => x.UpdatedOn)
      .Join(_productGroupTestMaster.GetAll(),
        versions => versions.ProductGroupCode,
        master => master.ProductGroupCode,
        (versions, master) => new { Versions = versions, Master = master })
      .Select(x => new ProductGroupDataList
      {
          Id = x.Versions.Id,
          QuestionType = x.Master.QuestionType,
          ProductGroupCode = x.Versions.ProductGroupCode,
          ProductGroupReferenceId = x.Master.ProductGroupReferenceId,
          ProductGroupTestName = x.Master.ProductGroupTestName,
          Description = x.Master.Description,
          VersionNo = x.Versions.VersionNo,
          Type = x.Versions.Type,
          TotalQuestionNo = x.Versions.TotalQuestionNo,
          Link = x.Master.Link,
          TestCreated = x.Versions.CreatedOn,
          Status = string.Empty,
          FreezeTime = x.Versions.FreezeTime,
          MaxAttempts = x.Versions.MaxAttempts,
          ExpireyInMonths = x.Versions.ExpiryInMonths,
          TestedBy = 0
      })
      .ToListAsync();

********************************************************************18**********************************************************
******************************************************************RestCall******************************************************
Approch 1:
	-Install RestSharp Package
	-implementation
		string _identityServerPath = "https://localhost:44301";
		var client = new RestClient(_identityServerPath);            // Creating new Client
		
		string url = "api/TokenAuth/Authenticate";                   // Create request
		var request = new RestRequest(url,Method.Post);
		
		request.AddHeader("Content-Type", "application/json");
		request.AddHeader("abp.tenantid", "1004");                    // Not pass it will taken from Token
		request.AddHeader("Authorization", _accessToken);

		
		var body = JsonConvert.SerializeObject(loginModel);
		equest.AddParameter("application/json",body,ParameterType.RequestBody);
		var response = client.Execute(request);
		
		
		jsonObj = JObject.Parse(response.Content)["result"];
		AuthenticateResultModel data = JsonConvert.DeserializeObject<AuthenticateResultModel>(JsonConvert.SerializeObject(jsonObj));
		return data.AccessToken;

********************************************************************19**********************************************************
************************************************************Swagger Documentation******************************************************
#Swagger Documentation

use Swashbuckle.AspNetCore package

Swagger (via Swashbuckle) can auto-generate API documentation by using attributes like SwaggerOperation, SwaggerResponse, SwaggerParameter, and others in the code.
These annotations provide descriptive information for each endpoint, such as:
- A summary of what the endpoint does.
- A description of how it works.
- Information about request/response types.
- Possible response codes.

---------------------------------------Implementation-------------------------------
[HttpGet("{agreementId}")]
[SwaggerOperation(
    Summary = "Details of agreement done by customer.",
    Description = "Complete details of agreement signed by customer and remain to sign."
)]
[SwaggerResponse(200, "Agreement details retrieved successfully", typeof(AgreementDetails))]
[SwaggerResponse(404, "Agreement not found")]
public IActionResult GetAgreementDetails(long agreementId)
{...}

--------------------------------program.cs-----------------------------
builder.Services.AddSwaggerGen(options =>
{
    // To enable annotations (SwaggerOperation, etc.)
    options.EnableAnnotations();

    // Optional: Add custom info to the Swagger UI
    options.SwaggerDoc("v1", new Microsoft.OpenApi.Models.OpenApiInfo
    {
        Title = "Your API Title",
        Version = "v1",
        Description = "API for managing agreements."
    });
});
-------------------------------------------------------------------------
SwaggerResponse:
Used to specify the expected HTTP response codes and the types of data returned by the endpoint.

SwaggerParameter:
Describes a parameter for an endpoint (used when the parameter doesn’t have a good name or description by default).

SwaggerTag:
Used to categorize or group operations in the Swagger UI.

********************************************************************20********************************************************************
**************************************************************Store Procedure*************************************************************
#Store Procedure
#Call Store Procedure From Code
#Write SP where join 2 Table and return

It a set of sql statement those can be save as single Unit at Database side

#Why we use Store Procedure
-less Network traffic it will run on DB level
-Code reusability
-secure
-Easy to Maintain (change in DB is better then Change in Code and Deployee);

#Normal Query 
  select b.firstName, b.MiddleName, a.JobTitle, a.BirthDate from [HR].[Employee] a inner join [Person].[Person] b
  on a.Id = b.Id;
  
------------------------------Store Procedure-----------------------------
 - Create SP 
	create proc sp_GetEmployeeData
	as
	begin
	select b.firstName, b.MiddleName, a.JobTitle, a.BirthDate from [HR].[Employee] a inner join [Person].[Person] b
	on a.Id = b.Id;
	end
 
 - Execute Sp
	exec [dbo][sp_GetEmployeeData]
  
 - Drop store Procedure
	drop proc [dbo][sp_GetEmployeeData]
---------------------------------------------------------------
# Input output parameter
 - Create SP (Input)
	create proc sp_GetJobTitleData(@JobTitle varchar(100))
	as
	begin
	select b.FirstName, b.MiddleName, b.JobTitle from [Hr].[Employee] a inner join [Person].[Person] b
	on b.Id = a.Id where JobTitle = @JobTitle
	end
 - Execute Sp
    - we can execute SP by GUI also -> RC->Execute SP and pass value
	- exec [dbo].[sp_GetJobTitleData] 'Senior Tool Designer'	
-------------------------------------------------------------------
 - Create SP (Input and Output Parameter)
	create proc sp_GetNationalId(@BusinessEntityId int, @NationalIdnumber int output)
	as
	begin
	select @NationalIdnumber = NationalIdnumber from [HR].[Employee] where BusinessEntityId = @BusinessEntityId 
	end
  
 -Execute SP(Declare Variable and execute)
	declare @NationalIdnumber int
	exec [dto].[sp_GetNationalId] 1, NationalIdnumber output
	select @NationalIdnumber
----------------------------------------------------------------------------------------------------------------------
CREATE TABLE Products(
	ProductID INT Identity PRIMARY KEY,
	ProductName VARCHAR(255) NOT NULL,
	Price money NOT NULL,
	Manufacturer VARCHAR(100),
	DataCreated datetime
	);
	----------------------------------------------	
	Parameterless SP
 -	create procedure dbo.sp_InsertProduct
	as
	begin
	declare @ProductName VARCHAR(255),
			@Proce money,
			@Manufacturer VARCHAR(100),
			@DateCreated datetime
			
	select  @ProductName = 'Laptop',
			@Price = 100,
			@Manufacturer = 'DELL',
			@DateCreated = '2024-01-02'
			
	insert into [dto].[Product]([ProductName],[Price],[Manufacturer],[DateCreated])
	values( @ProductName, @Price, @Manufacturer, @DateCreated )
	end
	
 -  exec dbo.sp_InsertProduct
   -----------------------------------------------
   parameterized SP
   
   create procedure dbo.sp_InsertProduct
	(	@ProductName VARCHAR(255) output,                 <----- Output Parameter
		@Proce money,
		@Manufacturer VARCHAR(100),
		@DateCreated datetime = null                      <----- To make it optional
	)
	as
	begin
	insert into [dto].[Product]([ProductName],[Price],[Manufacturer],[DateCreated])
	values( @ProductName, @Price, @Manufacturer, @DateCreated )
	
	set @ProductId = SCOPE_IDENTITY()                      <---- Current PRIMARY value
	
	select [ProductID],[ProductName][Price][Manufacturer],[DateCreated] from [Products] where ProductID = @ProductId
	end
   
   exec dbo.sp_InsertProduct 'Laptop',100,'DELL','2024-01-01'
   
--------------------------------------------------------------------------------------------------------------------------
-Add If not Exist
-Check If Exist
-Update Price


	create procedure dbo.sp_InsertProduct
	(	@ProductName VARCHAR(255),                 
		@Proce money,
		@Manufacturer VARCHAR(100),
		@DateCreated datetime = null                     
	)
	as
	begin	
	if not exists(select 1 from [Products] where [ProductName]=@ProductName and [Manufacturer] = @Manufacturer)
	begin
	insert into [dto].[Product]([ProductName],[Price],[Manufacturer],[DateCreated])
	values( @ProductName, @Price, @Manufacturer, @DateCreated )
	end
	
	ELSE
	if exists (select 1 from [Products] where [ProductName]=@ProductName and [Manufacturer]=@Manufacturer and [Price] = @Price)
	begin
	print 'Product already exists'
	end
	
	ELSE
	if exists (select 1 from [Products] where [ProductName]=@ProductName and [Manufacturer]=@Manufacturer and [Price] != @Price)
	begin
	update [Products]
	set Price = @Price where [ProductName] = @ProductName and [Manufacturer] = @Manufacturer
	end
	
	declare @ProductId int
	set @ProductId = (select top 1 ProductId from [Products] where [ProductName]=@ProductName and [Manufacturer]=@Manufacturer [Price] = @Price)	
	select [ProductID],[ProductName],[Price],[Manufacturer],[DateCreated] from [Products] where ProductId = @ProductID
	end
-------------------------------------------------Debug store Procedure------------------------------------------
- Debuging is Done by IDE
		View -> SQL server Object Explorer-> Add SQL server -> Provide SQL server instance name -> Connect		
		select DB -> store Procedure -> SP -> Rigth click -> Debug Procedure 
				
----------------------------------------------------Book Managment----------------------------------------------------------
https://youtu.be/heXYdyXZV-Q?si=y18T5EwvANoM-dBe

----------------------------------------------------E-Commers----------------------------------------------------------------
CREATE TABLE Products(
	ProductID INT PRIMARY KEY,
	ProductName NVARCHAR(100),
	UnitPrice DECIMAL(10,2),
	StockQuantity INT
	);
	
CREATE TABLE OrderHistory(
	OrderID INT identity PRIMARY KEY,
	ProductID INT,
	Quantity INT,
	OrderDate Date,
	CustomerID int,
	TotalPrice DECIMAL(10,2)
	);
	
CREATE TABLE Customers(
	CustomerID INT PRIMARY KEY,
	FirstName NVARCHAR(50),
	LastName NVARCHAR(50),
	Email NVARCHAR(100),
	PhoneNumber NVARCHAR(10),
	Address NVARCHAR(255)
	);
	
INSERT INTO Products(ProductID, ProductName, unitPrice, StockQuantity)
VALUES
		(1,'Laptop',100.00,50),
		(2,'SmartPhone',650.00, 100),
		(3, 'Table', 350.50,75) 

INSERT INTO Custmers (CustomerID,FirstName,LastName,Email,PhoneNumber,Address)
VALUES	
		(1,'John','Doe','john.doe@example.com','123-456-7890','solapur'),
		(2,'Jane','Smith','jane.smith@example.com','111-456-7890','pandharpur'),
		(3,'Alice','Johnson','alica.johnson@example.com','222-456-7890','pune'),
		
select * from Products
select * from OrderHistory
select * from Customers


CREATE PROCEDURE ProcessOrder
@ProductId int,
@Quantity int,
@CustomerID int
as
begin

--Start the transaction
BEGIN TRANSACTION    

DECLARE @CurrentStockQuantity int
DECLARE @NewStockQuantity int

--get the current stock quantity for a product
SELECT @CurrentStockQuantity = StockQuantity FROM Products where ProductID = @ProductID

--Check if there is enough stock quantity available to fulfill the order

IF @Quantity <= @CurrentStockQuantity
BEGIN
--get the new stock quantity after the order
SET @NewStockQuantity = @CurrentStockQuantity - @Quantity

DECLARE @TotalPrice decimal(10,2)
set @TotalPrice = (SELECT UnitPrice *@Quantity from Products where ProductID = @Productid)

UPDATE Products
SET StockQuantity = @NewStockQuantity
WHERE ProductID = @ProductID

INSERT INTO OrderHistory([ProductID],[Quantity],[OrderDate],[CustomerID],[TotalPrice])
VALUE(@ProductId,@Quantity, GETDATE(),@CustomerId,@TotalPrice)

--commit transaction

COMMIT TRANSACTION
END

ELSE
BEGIN
PRINT 'Error: Insufficient StockQuantity to fulfill the Order'

rollback transaction
END
end
 
---------------------------------------------------------------------------------------------------------
avoid to see 1 no affected msg we can add line
SET NOCOUNT ON;

-----------------------------------------Function-------------------------------------
#User Defined Function
1. Scalar Function : Alway return a single value
				ex. length(), substring()
				
syntext:	
	CREATE FUNCTION FUNCTION_NAME
	(@Parameter1 DATATYPE, 
	@Parameter2 DATATYPE,...)
	RETURNS Return_Datatype
	AS
	BEGIN
	--Function Body--
		RETURN Return_Datatype
	END

2. Table Value Function: TVF always return a Single value
	
syntext:
	CREATE FUNCTION [schema_name].functionName
	([@parameter name] [data_type])
	RETURNS TABLE
	AS
	RETURN
	(
		SELECT column1, column2
		FROM table_name
		WHERE condition
	)
---------------------------------------------------------------
DEMO
  Create Function:	
	CREATE FUNCTION fn_GetFullName(@Id int)
	RETURNS VARCHAR(100)
	AS
	BEGIN
	DECLARE @FullName varchar(100)
	
	SELECT @FullName = first_name +' '+last_name from Email
	where id = @Id
	return @fullName	
	END	
	
 Execute Function:
	SELECT DBO.fn_GetFullName(1)                <--- return single value
	SELECT DBO.fn_GetFullName(1) as FullName from [dbo].[Email]        <--- return complete table with additional column FullName
	
	
------------------------------------------------------------View-----------------------------------------------------
Create :
	CREATE VIEW vw_Person
	as
	select BusinessEntityId, FirstName, MiddleName, LastName from [Person].Person
	where MiddleName is not null
	
Execute : select * from vw_Employee_Person


------------------------------------------------------Call SP From Code------------------------------------------------

 public class Repository : IRepository
 {
     public MyDbContext Context { get; set; }    
     public Repository(MyDbContext myDbContext)
     {
         Context = myDbContext;
     }


     public async Task<List<Party>> GetParties() 
     {
        return await Context.Set<Party>().FromSqlRaw("EXEC test_pro").ToListAsync();
     }
 }
 
  public async Task<List<User>> CallStoreProcedure()
 {
    return await _context.Users.FromSqlRaw("EXEC getUserSP").ToListAsync();
 }
 
-------------------------------------------------------------------------------------------------
await Context.Database.ExecuteSqlAsync("EXEC test_pro");
will execute the stored procedure and return the number of rows affected (for a query like UPDATE, INSERT, etc.).


*******************************************************3*****************************************
1. Create a Stored Procedure that Joins Two Tables

CREATE PROCEDURE GetPartyAndEventDetails
AS
BEGIN
    SELECT p.Id AS PartyId, p.Name AS PartyName, e.Id AS EventId, e.Name AS EventName
    FROM Party p
    INNER JOIN Event e ON p.Id = e.PartyId
END

2. Define a DTO 

public class PartyEventDetailsDto
{
    public int PartyId { get; set; }
    public string PartyName { get; set; }
    public int EventId { get; set; }
    public string EventName { get; set; }
}

3. Call the Stored Procedure from Entity Framework

// Calling the stored procedure and returning the result as a list of PartyEventDetailsDto
public async Task<List<PartyEventDetailsDto>> GetPartyAndEventDetails()
{
	// Execute the stored procedure and map the result to PartyEventDetailsDto
	var result = await _context.Set<PartyEventDetailsDto>()
		.FromSqlRaw("EXEC GetPartyAndEventDetails") // Execute the stored procedure
		.ToListAsync(); // Convert the result to a list

	return result;
}		
************************************************************21********************************************************************
******************************************************* IConfiguration ***********************************************************
If we want to get Environment variables defined in appsetting.

        private readonly IConfiguration _appConfiguration;
		public ReportHistoryService(IConfiguration _config,IWebHostEnvironment env) 
		 {
			 _appConfiguration = i1Core.CommonLibrary.Configuration.EnvironmentExtensions.GetAppConfiguration(env);     <--- for getting global appsettings.json
			 test = env.GetAppConfiguration();  <---- for getting current appsetting.json
		 }
		 
		----------------------------------------CommonLibrary--------------------------------------
namespace i1Core.CommonLibrary.Configuration;

public static class EnvironmentExtensions
{
    public static IConfigurationRoot GetAppConfiguration(this IWebHostEnvironment env)
    {
        string environmentVariable = Environment.GetEnvironmentVariable("AppsettingsFilePath");
        return AppConfigurations.Get((environmentVariable != "" && environmentVariable != null) ? environmentVariable : env.ContentRootPath, env.EnvironmentName, env.IsDevelopment());
    }
}

********************************************************************22********************************************************************
************************************************************** Cors policy *************************************************************
#add configuration in program.cs file to allow only specific url

builder.Services.AddCors(o =>
{
    o.AddPolicy("myCorsPolicy", policy =>
    {
        policy.WithOrigins("http://localhost:4200").AllowAnyHeader().AllowAnyMethod();
    });
});

app.UseCors("myCorsPolicy");


********************************************************************23********************************************************************
************************************************************** Mail Functionality *************************************************************
  
  public void SendEmail(string toEmail, string subject, string body)
  {
      var fromEmail = Configuration.GetSection("Constants:FromEmail").Value ?? string.Empty;
      var fromEmailPassword = Configuration.GetSection("Constants:EmailAccountPassword").Value ?? string.Empty;

      var message = new MailMessage()
      {
          From = new MailAddress(fromEmail),
          Subject = subject,
          Body = body,
          IsBodyHtml = true
      };

      message.To.Add(toEmail);

      var smtpClient = new SmtpClient("smtp.gmail.com")
      {
          Port = 587,
          Credentials = new NetworkCredential(fromEmail, fromEmailPassword),
          EnableSsl = true,
      };

      smtpClient.Send(message);
  }

#To create Password
	Go to google account -> security -> 2 step-verification -> password -> Name -> Create

*********************************************************24.Azure**********************************************************************************
 
Azure is Microsoft's cloud computing platform and service that provides a wide range of cloud-based solutions for building, deploying, and managing applications and services. 
Azure offers both Infrastructure as a Service (IaaS) and Platform as a Service (PaaS), as well as software solutions for developers, businesses, and organizations
	- Infrastructure as a Service (IaaS): Provides virtual machines (VMs) and storage resources that can be used to build custom infrastructure on demand.
	- Platform as a Service (PaaS): Allows developers to build applications without having to manage the underlying infrastructure. Services like Azure App Service fall under PaaS, enabling developers to focus on code rather than managing servers.
	 
Key Azure Services and Components:
	- Virtual Machines (VMs): Allow users to run custom applications or services in the cloud without needing physical hardware.
	- Azure Storage: Offers scalable and durable storage options like Blob Storage, File Storage, Disk Storage, and Queue Storage  
*********************************************************25.RDLC Report**********************************************************************************
RDLC Report
refer video : https://youtu.be/So-BzxAA7Tw?si=HyGWGgcT6PIp0Bbl
Required Extention : Microsoft RDLC Report Designer
Required Nuget : ReportViewerCore.NETCore / Microsoft.ReportViewer.WebForm/Microsoft.ReportingServices.ReportViewerControl.Winforms

1.Create Dataset
	NewFolder(Datasets)->New Item->Data->DataSet 
		Add Datasets()
2.Create repot
	NewFolder(repot) ->New Item-> Report
	Create repot structure
--------------------------------------------------------
public IActionResult PrintReport()
{
	
    var dt = new DataTable();
	dt = GetEmployeeList();
	
	using var report = new LocalReport();
	report.DataSources.Add(new ReportDataSource("dsEmployee",dt));
	var parameter = new[] { new ReportParameter("param1", "RDLC Sub-Report Example") };
    report.ReportPath = $"{this._webHostEnvironment.WebRootPath}\\Reports\\rptEmployee.rdlc";   <----- report path
	report.SetParameters(parameter);
	report.SubreportProcessing += new SubreportProcessingEventHandler(SubReportProcessing);
	var pdf = report.Render(renderFormate);
	return File(pdf,"application/pdf","Report.pdt");

}

 void SubReportProcessing(object sender, SubreportProcessingEventArgs e )
 {
     int empId = int.Parse(e.Parameters["EmpId"].Values[0].ToString());
     var dt2 = new DataTable();
     dt2 = GetEmployeeDetailsList().Select("EmpId="+empId).CopyToDataTable();
     ReportDataSource ds = new ReportDataSource("dsEmployeeDetails",dt2);
     e.DataSources.Add(ds);
 }
 
 public DataTable GetEmployeeList()
 {
     var dt = new DataTable();
     dt.Columns.Add("EmpId");
     dt.Columns.Add("EmpName");
     dt.Columns.Add("Department");
     dt.Columns.Add("Designation");

     DataRow row;
     for (int i = 0; i <= 120; i++) 
     {
         row = dt.NewRow();
         row["EmpId"] = i;
         row["EmpName"] = "Akash"+i;
         row["Department"] ="Information technology";
         row["Designation"] = "Software Engineer";
         dt.Rows.Add(row);
     }
     return dt;
 }

 public DataTable GetEmployeeDetailsList()
 {
     var dt = new DataTable();
     dt.Columns.Add("EmpId");
     dt.Columns.Add("Details");
    DataRow row;
     for (int i = 101; i <= 120; i++)
     {
         for(int j = 1;j<=3;j++)
         {
             row = dt.NewRow();
             row["EmpId"] = i;
             row["Details"] = "Gund-" + j;
             dt.Rows.Add (row);
         }
     }
     return dt;
 }
----------------------------------------------------------------------------------------