#DOTNET üìå
1. difference between var and let
2. What is difference between put and patch
3. command for convert typeScript into javascript
4. difference between typeScript and javascript
5. What is Entity framwork
6. Routing in C#
7. State management system
8. Client side vs server 
9. httpResponce
	Status Codes
10. Design patterns
11. Difference between Abstracting & Encapsulation
12. Delete and Truncate difference
13. How we decide go with abstract class or interfaces. 
14. Transient vs scoped
15. Sealed class and Static class difference	
16. Major Difference Between Sql Server and PostGreSql
17. IActionResult
18. SOLID Principle
19. Agile methodology
20. Garbage collection
21. Difference between Abstract class and interface
22. Model binding
23. Filter in ASP .NET Core
24. Action Parameters [FormBody], [FormQuery]
-----------
#CODING üìå
1.give me no of occuerence for each word from hello (count)

-----------
#DATABASE üìå
1.In SQL how do you optimize stored procedures
2.Difference between VARCHAR and NVARCHAR
3.SQL Command/ Type of DB languge
4.ACID Property
5.Store Procedure VS function
6.Joins, View, Trigger
7.Normalization
8.What is the use of temp tables and table variable

---------
#SQL QUERY PROBLEMS üìå
1. Second highest salary and third highest salary
2. All element not duplicate SQL query
3. Retrieve duplicate records from a table
4. Delete duplicate rows from a table while keeping one copy
5. What are INNER JOIN, LEFT JOIN, RIGHT JOIN, and FULL OUTER JOIN? Give examples.
6. Find employees who earn more than the average salary in their department.
7. Find employees who do not belong to any department (use LEFT JOIN).
8. Query to get employees who joined in the last 30 days.
9. What is the difference between ROW_NUMBER(), RANK(), and DENSE_RANK()?

-----------------------------------------1.difference between var and let------------------------------------------
1. Scope
var: Has function scope (or global scope if declared outside a function). This means it is accessible throughout the function it was declared in, even before the declaration (due to hoisting).	
let: Has block scope. This means it is only accessible within the block (like within loops, if statements, etc.) where it was declared.
Example:
if (true) {
  var x = 5;
  let y = 10;
}

console.log(x); // 5 (because `var` is function scoped)
console.log(y); // ReferenceError: y is not defined (because `let` is block scoped)

2 Re-declaration
var: You can re-declare a variable within the same scope using var without any issues.
let: You cannot re-declare a variable in the same scope with let. If you try, it will result in a SyntaxError.
Example:
var x = 5;
var x = 10; // No error, re-declaration is allowed

let y = 5;
let y = 10; // SyntaxError: Identifier 'y' has already been declared

*****************************************2. What is difference between put and patch************************************
1. Full vs. Partial Update
PUT: A PUT request is used to update a resource entirely. When you send a PUT request, the entire resource is replaced with the new data you provide. If a field is missing from the request, it will be overwritten (or removed) in the resource.
PATCH: A PATCH request is used to update a resource partially. Instead of replacing the entire resource, you only send the fields that need to be updated. It‚Äôs more efficient when you only need to modify a small part of the resource.

-If you need to replace a resource entirely, use PUT.
-If you only need to update specific parts of a resource, use PATCH.

Put:
if we have object like
{
  "id": 1,
  "username": "johndoe",
  "email": "john@example.com",
  "bio": "Updated Bio!",
  "age": 31
}
If any field is missing in the request body, it'll be removed or defaulted (e.g., null for strings).

Patch:

Patch used for update partially, if we update single filed remain filed will be same. 
‚úîÔ∏è This uses Microsoft.AspNetCore.JsonPatch, which you need to install:
dotnet add package Microsoft.AspNetCore.Mvc.NewtonsoftJson

And in Program.cs or Startup.cs:
builder.Services.AddControllers().AddNewtonsoftJson(); // Required for PATCH support


***************************************3.command for convert typeScript into javascript********************************
for compile
tsc example.ts
Watch for changes and automatically recompile:
tsc --watch
If you have a hello.ts file:
Running tsc hello.ts will generate hello.js

***************************************4.difference between typeScript and javascript***************************************
1. Typing System
JavaScript: JavaScript is dynamically typed. This means variables can change types at runtime and don't require explicit type declarations. 
For example:
let message = "Hello";
message = 42; // No error, as types can change at runtime

TypeScript: TypeScript is statically typed (optionally). It allows you to define types explicitly, and these types are checked during compile-time, which helps catch errors early.

let message: string = "Hello";
message = 42; // Type error: Type 'number' is not assignable to type 'string'

2. Compilation
- JavaScript: JavaScript is an interpreted language. It runs directly in the browser or on Node.js without needing any compilation.
- TypeScript: TypeScript is a superset of JavaScript. It requires a compilation step to convert TypeScript code into standard JavaScript. This is done using the TypeScript compiler (tsc), which checks the types and compiles the TypeScript code into plain JavaScript that can run in any JavaScript environment.

4. Features
JavaScript: JavaScript supports ES6 features (like arrow functions, async/await, modules, etc.) and older features. The language is constantly evolving, but it doesn‚Äôt natively support things like interfaces, generics, or advanced type features.
TypeScript: TypeScript supports all JavaScript features (including ES6 and beyond) and adds its own features, such as:
Interfaces: TypeScript allows defining strict contract shapes for objects, helping with better code structure and maintainability.
Generics: You can create reusable components with type parameters.
Enums: TypeScript supports enum types, which are not available in vanilla JavaScript.
Type Aliases and Custom Types: Create complex types and use them throughout your code.

*********************************************5.What is Entity framwork*****************************************************************
Defination:
- Entity Framework (EF) is open-source Object-Relational Mapper (ORM) developed by Microsoft that enables developers to work with relational databases using .NET objects. 
- its like wrapper on ADO.Net. EF Minimize the coding effort.
 Essentially, EF allows you to interact with your database using object code instead of raw SQL queries, which makes data access easier and more intuitive.

1.Object-Relational Mapping (ORM):  automatically maps the objects in your application to the tables in your database. 

For ex. we have Student class, Employee class there calsses will be directly matched with database tables. the properties will be table columns.
 
****************************************************6.Routing in C#****************************************************
- Routing is used to handle incoming HTTP requests based on the URL and maps them to a controller action or endpoint.

in startup.cs file
            app.UseRouting();   <---- configure routing;


Ex: http://localhost/home/index/100
home: controller
index: action method
100: id parameter value

public class HomeControler: Controller
{
	public ViewResult Index()
	{
	  return View();
	}
}
--------------------------------------
#what is attribute routing in ASP.NET Core?
-Attribute based routing is the ability to manupulate the behavior of URL by route attribute
Ex: http://localhost/home/NewIndex

[Route("NewIndex")]				<---- we use route attribute
public IActionResult Index()
{
	return View();
}

****************************************************7.State management system****************************************************
state management in asp.net core has various techniques used to store user data across different requests. since HTTP is stateless, each request is new for server, it does not remember previous request.
#state management techniques:
1. Session State
Description: Session state allows you to store data for a user across multiple HTTP requests. Data is stored on the server and is associated with a unique session ID, which is typically stored in a cookie on the client.
EX:
public class HomeController : Controller
{
    public IActionResult Index()
    {
        // Set session value
        HttpContext.Session.SetString("UserName", "JohnDoe");

        return View();
    }

    public IActionResult GetSessionValue()
    {
        // Get session value
        var userName = HttpContext.Session.GetString("UserName");
        return Content(userName);
    }
}
Configuration: To enable session state, you need to add session services and configure it in

public void ConfigureServices(IServiceCollection services)
{
    services.AddDistributedMemoryCache(); // For in-memory session storage
    services.AddSession(options =>
    {
        options.IdleTimeout = TimeSpan.FromMinutes(30); // Session timeout
    });
}

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseSession();
}
----------------------------------------------------------------------------
2. Cookies
Description: Cookies are small pieces of data stored on the client-side (browser). They can be used to persist user preferences, authentication tokens, or any other small pieces of data.
Types:
1.Persistent Cookies: These cookies have an expiration date, and they are stored on the client machine until the expiration date is reached.
2.Session Cookies: These cookies are temporary and are deleted when the browser is closed.

public IActionResult SetCookie()
{
    Response.Cookies.Append("UserPreference", "DarkMode", new CookieOptions
    {
        Expires = DateTimeOffset.UtcNow.AddDays(1) // Persistent cookie
    });
    return View();
}

public IActionResult GetCookie()
{
    var userPreference = Request.Cookies["UserPreference"];
    return Content(userPreference ?? "No preference set");
}
-------------------------------------------------------------------------
3. Query Strings
Description: Query strings are data passed in the URL in key-value pairs (e.g., /Home/Index?id=123). While not ideal for sensitive or large data, they are a simple way to transfer small pieces of data between requests.
public IActionResult Index(int? id)
{
    var userId = id ?? 0;
    return Content($"User ID: {userId}");
}
---------------------------------------------------------------------------
4. TempData
Description: TempData is used to store data that is only needed for the next request. It is typically used to pass data between controller actions, often used for displaying success/error messages.
Storage: TempData is stored in session but is cleared after it is read once.

public IActionResult SetTempData()
{
    TempData["Message"] = "Data saved successfully!";
    return RedirectToAction("ShowTempData");
}

public IActionResult ShowTempData()
{
    var message = TempData["Message"];
    return Content(message?.ToString() ?? "No message");
}
---------------------------------------------------------------------------
5. ViewData and ViewBag
Description: ViewData and ViewBag are used to pass data from the controller to the view. ViewData is a dictionary, while ViewBag is a dynamic object. These are typically used to send data to the view for rendering purposes.
public IActionResult Index()
{
    ViewData["Message"] = "Hello from ViewData";
    ViewBag.Message = "Hello from ViewBag";
    return View();
}
-------------------------------------------------------------------------
Summary of Techniques:
Session State: Stores data for the duration of the user‚Äôs session.

Cookies: Stores small pieces of data on the client-side.

Query Strings: Transmits data via the URL.

TempData: Stores data for the duration of a single request.

ViewData/ViewBag: Pass data from the controller to the view.

*********************************************8.Client side vs server side **********************************
Client-Side:
Definition: Client-side refers to operations that are performed on the user's machine, typically within the browser. This can include things like rendering HTML, running JavaScript,

Server-Side
Definition: Server-side refers to operations that are performed on the web server, where the application logic runs, and where requests from the client are processed.

***********************************************9.httpResponce*********************************************
The HttpResponse object is a powerful part of the ASP.NET Core framework that allows you to control the response sent back to the client.
It handles everything from status codes and headers to cookies, redirections, and writing the response body. 

1.Status Code: The HttpResponse.StatusCode property is used to set the HTTP status code that will be sent to the client.
// Set the status code to 200 (OK)
HttpContext.Response.StatusCode = 200;

// Set the status code to 404 (Not Found)
HttpContext.Response.StatusCode = 404;
------------------------------------------------------------
2.Headers:The HttpResponse.Headers property allows you to add or modify HTTP headers in the response.
// Add a custom header to the response
HttpContext.Response.Headers["Custom-Header"] = "HeaderValue";

// Set the Content-Type header
HttpContext.Response.ContentType = "application/json";
------------------------------------------------------------
2.Cookies: You can use the HttpResponse.Cookies property to set cookies in the response. Cookies are stored on the client side 
// Set a cookie in the response
HttpContext.Response.Cookies.Append("UserName", "JohnDoe", new CookieOptions
{
    Expires = DateTimeOffset.UtcNow.AddDays(7) // Expire in 7 days
});
--------------------------------------------------------------
public async Task<IActionResult> Index()
{
    // Set the status code
    HttpContext.Response.StatusCode = 200;

    // Add custom headers
    HttpContext.Response.Headers["Custom-Header"] = "HeaderValue";
    HttpContext.Response.ContentType = "application/json";

    // Set a cookie
    HttpContext.Response.Cookies.Append("UserName", "JohnDoe");

    // Write some content to the response body
    await HttpContext.Response.WriteAsync("{ \"message\": \"Hello World!\" }");

    return new EmptyResult(); // No additional content
}

Explanation of what happens in this action:

Status Code: The status code is set to 200 (OK), indicating the request has been processed successfully.

Custom Headers: A custom header called Custom-Header with the value HeaderValue is added to the response.

Content-Type: The content type of the response is set to application/json, indicating that the response body will contain JSON data.

Cookie: A cookie named UserName with the value JohnDoe is set in the client's browser.

Response Body: The response body will contain a JSON string: {"message": "Hello World!"}.

Return Type: An EmptyResult is returned, but since the response body and status code are already set, this result won't affect the response that the client receives. Essentially, it indicates no further processing is required.
---------------------------------------------Status Codes----------------------------------------------
200 : Success/OK
201 : Created
204 : No data Found
400 : Bad request
401 : unauthorized
403 : Forbidden
404 : Not Found
500 : Internal server error
504 : Gateway Timeout
***************************************10.Design patterns******************************************************
Q. What is design pattern?
 - A design pattern is a reusable solution to a common problem in software design. There are 3 types of Design patterns:

1.Creational design pattern
2.Structural design pattern
3.Behavioral design pattern

1.Creational design pattern:
Creational design patterns are design pattern that deals with object creation mechanisms.
for ex: Singleton design patterns.,Factory design pattern

2.Structural design pattern
Structural design pattern is used to manage the structure of classes and interfaces as well to manage the relationship between the classes
for ex: Dependency Injection(DI)

3.Behavioral design pattern
this type deals with the communication between classes and objects.
for ex: Iterator,  Unit of work , Repository Pattern 

**********************************************Creational design pattern:*******************************
1.Singleton design pattern
2.Factory design pattern
3.Lazy Initialization

1. Singleton design pattern
- its a creational design pattern becouse it deals with object creation mechanism.
- a singleton is a class that only allows a single instance of itself to be created.
- this pattern is used when we need to ensure that only one object of a particular class need to be created.
- The Singleton Design Pattern is a simple but effective way to ensure that a class has only one instance throughout the entire application, providing a controlled and global access point to that instance. 
It is useful when managing resources like database connections or configuration settings.
Steps for create singleton class:
1.Create a sealed class so no one can inherit from this class.
2.Create private constructor so that no one can create object of this singleton class. (no one can inherit this class)
3.Declare a static instance of this class
4.Create a method which will check where the instance is null, if yes then it will create the new instance and if no then it will return the same instance.

public sealed class Singleton                   <----- 1
{
	private static Singleton instance;			<----- 3
	
	private Singleton(){}						<----- 2
	
	public static Singleton getInstance()		<----- 4
	{
		if(instance == null)
		{
			return new Singleton();
		}
		return instance;
	}
	
}

public static void main(string[] args)
{
	Singleton s1 = Singleton.getInstance();
}


##why sealed keyword is requird
we can create nested class and the by using nested class we can create multiple object of singleton class which violate the principle of singleton pattern

public sealed class Singleton                   
{
	private static Singleton instance;			
	
	private Singleton(){}						
	
	public static Singleton getInstance()	
	{
		if(instance == null)
		{
			instance = new Singleton();
			return instace;
		}
		return instance;
	}
	
	public class DerivedSingleton: Singleton
	{
	
	}	
}


public static main()
{
	Singleton s1 = Singleton.getInstance();       <---- 1 instace created 
	Singleton s2 = Singleton.getInstance();       <---- same instace refer to the s2
	
	
	Singleton.DerivedSingleton derivedObj = new Singleton.DerivedSingleton(); <---- at this movement 2nd instance will create which violate principle of singleton pattern.
}


##How to make singleton pattern thread safe
Thread safe singleton pattern can be implemented by using the Lock mechanism. so that multiple threads cannot create multiple instance of same class.

public sealed class singleton
{
	private static Singleton instace = null;
	private static readonly object obj = new object();
	 
	private singleton(){}
	
	public static Singleton getInstance()
	{
		if(instance == null)			---- use double check to avoid locking. bcz lock unessesory hold the resource multiple time. 
		{
			private lock(obj)
			{
				if(instance == null)
				{
					instace = new Singleton();
				}
			}
		}
		  return instance;
	}
}

how can add Thread sefty:
	by using lock object we can make thread sefty. 

#Connection with AddSingleton<IEmployee, Employee>();
-The AddSingleton method in ASP.NET Core's Dependency Injection (DI) container registers services with a singleton lifetime. This means that only one instance of the service will be created and shared across the entire application's lifetime.
-When you register a service as a singleton, you are essentially applying the Singleton Design Pattern to that service. 
AddSingleton<IEmployeeService, EmployeeService>() ensures that one instance of EmployeeService is created and shared across the entire application.

--------------------------------2.Factory design pattern--------------------------------
- factory is a creational design pattern which manages object creation. in this pattern an interface is used for creating an object, but let subclass decide which class to instantiate.
- Factory pattern creates object without exposing the creation logic to the client and refer to newly created object using a common interface.

Ex:
[Client]--uses-->[Factory]--create-->[Product]
client uses a factory to create a instance of product.
--------------------------------3.Lazy Initialization--------------------------------
- The Lazy Initialization pattern delays the creation of an object until it is actually needed. 
- This is useful for improving performance, particularly when dealing with expensive operations or resources that may not be required immediately.
- n C#, lazy loading is often implemented using the Lazy<T> class, which is part of the System namespace. The Lazy<T> class ensures that an object is created only when it is accessed for the first time. This can save memory and processing time by avoiding the initialization of objects that may not be used.
Example of Lazy Loading in C#:
using System;

class Program
{
    // Define a class for Lazy loading
    public class ExpensiveObject
    {
        public ExpensiveObject()
        {
            Console.WriteLine("ExpensiveObject Created");
        }

        public void DoSomething()
        {
            Console.WriteLine("Doing something...");
        }
    }

    static void Main()
    {
        // Lazy initialization of ExpensiveObject
        Lazy<ExpensiveObject> lazyExpensiveObject = new Lazy<ExpensiveObject>(() => new ExpensiveObject());

        Console.WriteLine("Before accessing the expensive object");

        // The expensive object is created here (lazy loading)
        lazyExpensiveObject.Value.DoSomething();

        Console.WriteLine("After accessing the expensive object");
    }
}

----------------------------------------Structural Design pattern-----------------------------------------
1.Dependency Injection (DI) : 
Pattern Description: 
- This design pattern allows for decoupling the components of an application. Rather than hard-coding dependencies within a class, they are provided to the class by a DI container.
- ASP.NET Core has built-in support for DI. The framework allows services (like database context, logging, authentication, etc.) to be injected into classes (controllers, services, etc.) at runtime, enhancing testability and modularity.
Example: In Startup.cs, you configure services that the framework will inject into your application.

public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext<MyDbContext>(options => options.UseSqlServer("ConnectionString"));
    services.AddScoped<IMyService, MyService>();
}
#Why DI is considered a Structu	ral Pattern:
Decoupling Components: DI promotes decoupling between classes by allowing their dependencies (e.g., services, repositories) to be provided externally instead of creating them internally. This allows classes to focus on their primary responsibilities without worrying about how to create or manage their dependencies.

#In ASP.NET Core, DI is commonly implemented using the following techniques:
Constructor Injection (most common)
Property Injection
Method Injection
----------------------------------------Behavioral Design Pattern---------------------------------------
1.Repository Pattern 
    - Repository Pattern help to abstract and centralize the data access logic in an application. 
	- it provides a layer of separation between the application's business logic and data access code, making the code more modular, maintainable, and testable.

Example:
public interface IProductRepository
{
    Task<IEnumerable<Product>> GetAllProductsAsync();
    Task<Product> GetProductByIdAsync(int id);
}

public class ProductRepository : IProductRepository
{
    private readonly MyDbContext _context;

    public ProductRepository(MyDbContext context)
    {
        _context = context;
    }

    public async Task<IEnumerable<Product>> GetAllProductsAsync()
    {
        return await _context.Products.ToListAsync();
    }
}
2. iterator pattern :- helps iterate over elements of an aggregate object sequentially without exposing the underlying representation of the object.
						when you use a foreach loop in C#, you are indirectly using the Iterator design pattern.
						
3. Unit of work :- This pattern helps to manage transactions and changes made to objects.
				
	Note: ABP Framework, which has its own built-in support for the Unit of Work (UoW) pattern, designed to simplify transaction management, especially in multi-tenant and domain-driven design applications.
	üìå Key Benefits in ABP: no need to manually commit/rollback.

***************************11.Difference between Abstracting & Encapsulation*************************************************
Abstraction:
		- Abstraction is used for hiding unwanted data and showing issential things.
		- you can achive abstraction using Interface and Abstract class.
		- Abstraction solving the problem in design level.
		- Abstraction let you focus on what the object does instead of how it does it.
		- Purpose: To reduce complexity and allow the user to interact with the object at a higher level of understanding.
		-EX : outer look of mobile phone, like it has a display screen and keypad buttons to dial a number. 
Encapsulation:
		- Encapsulation means combine code and behavior into one single unit.
		- you can implement encapsulation using Assess modifiers.(public, protected and private).
		- Encapsulation solves the problem in implementation level.
		- Encapsulation means hiding the internal details of how an object does
		- Purpose:  To protect the object's state from harmful modifications, promoting controlled access to data.
		-Ex : inner implementation details of a mobile, how keypad button and display screen are connect with each other using circuits. 
	Abstraction:
	public abstract class EmployeeSalary
	{
		public int CalculateSalary()
		{
			return 10*3000;
		}
	}

	public class Employee : EmployeeSalary
	{
	}

	Main()
	{
		Employee e = new Employee();
		int sal = e.CalculateSalary();   <--- Abstraction  without knowing interanl logic we access method 
	}
	---------------
	public class Employee
	{
		private int empExperience;
		public int EmployeeSalary
		{
			get{return empExperience;}
			set {empExperience = value;}
		}
	}

	for getting empExperience we need to call property.

		
		
----------------------------how can achive abstraction using abstract class---------------------
// Abstract class
abstract class Animal {
    // Abstract method (no implementation)
    abstract void sound(); 

    // Concrete method (with implementation)
    void eat() {
        System.out.println("This animal is eating.");
    }
}

// Concrete class (subclass) that extends the abstract class
class Dog : Animal {
    // Providing implementation for the abstract method
   public override void sound() {
        System.out.println("Bark");
    }
}

class Cat : Animal {
    // Providing implementation for the abstract method
   public override void sound() {
        System.out.println("Meow");
    }
}

public class Main {
    public static void main(String[] args) {
        // You cannot create an object of an abstract class directly
        // Animal animal = new Animal(); // This will give an error

        // Creating objects of concrete classes
        Animal dog = new Dog();
        Animal cat = new Cat();

        // Calling methods on the objects
        dog.sound();  // Output: Bark
        dog.eat();    // Output: This animal is eating.

        cat.sound();  // Output: Meow
        cat.eat();    // Output: This animal is eating.
    }
}

#Full opps concent snippet
using System;

namespace OOPConceptsDemo
{
    // Abstraction using abstract class
    public abstract class Animal
    {
        // Public property
        public string Name { get; set; }

        // Protected field (can only be accessed in this class and derived classes)
        protected int age;

        // Constructor to demonstrate protected field usage
        protected Animal(string name, int age)
        {
            Name = name;
            this.age = age;
        }

        // Abstract method (must be implemented in derived class)
        public abstract void MakeSound();

        // Virtual method (can be overridden)
        public virtual void Eat()
        {
            Console.WriteLine($"{Name} is eating.");
        }

        // Public method to show encapsulated protected field
        public void ShowAge()
        {
            Console.WriteLine($"{Name} is {age} years old.");
        }
    }

    // Inheritance and Polymorphism
    internal class Dog : Animal
    {
        public Dog(string name, int age) : base(name, age) { }

        // Overriding abstract method
        public override void MakeSound()
        {
            Console.WriteLine($"{Name} says: Woof!");
        }

        // Overriding virtual method
        public override void Eat()
        {
            Console.WriteLine($"{Name} is munching on dog food.");
        }

        // Static method
        public static void ShowDogInfo()
        {
            Console.WriteLine("Dogs are loyal animals.");
        }

        // Using protected member from base class
        public void IncreaseAge()
        {
            age++;
            Console.WriteLine($"{Name} is now {age} years old.");
        }
    }

    internal class Cat : Animal
    {
        public Cat(string name, int age) : base(name, age) { }

        public override void MakeSound()
        {
            Console.WriteLine($"{Name} says: Meow!");
        }
    }

    public class Program
    {
        public static void Main()
        {
            Animal myDog = new Dog("Rex", 5);
            Animal myCat = new Cat("Whiskers", 3);

            myDog.MakeSound();     // Rex says: Woof!
            myDog.Eat();           // Rex is munching on dog food.
            myCat.MakeSound();     // Whiskers says: Meow!
            myCat.Eat();           // Whiskers is eating.

            myDog.ShowAge();       // Rex is 5 years old.
            myCat.ShowAge();       // Whiskers is 3 years old.

            Dog.ShowDogInfo();     // Static method

            // Accessing Dog-specific method
            Dog dogInstance = (Dog)myDog;
            dogInstance.IncreaseAge(); // Rex is now 6 years old.
        }
    }
}


*************************************************12.Delete and Truncate difference*************************************
Delete:
		- is a DML operation
		- The delete statement is used to remove specific rows from table. you can use a where cluse to filter the rows that need to be delete.
		- if the table has trigger associated with DELETE they will be fired when you use DELETE.
		- delete operation can be rollback bcz it's DML operation.
		- Performance is slower that trucate becouse it delete rows one by one.
		- does not reset identity column value.
Truncate:
		- is a DDL operation
		- The truncate statment is used to remove all rows from a table.
		- since truncate is DDL operation, it does not active triggers on the table.
		- truncate cannot be rollback bcz its DDl operation.
		- performance is fast becosue it remove all rows at time.
		- it reset identity column value. 
		

************************************************13. How we decide go with abstract class or interfaces. *************************
1.Purpose:
- Use an Interface when you need to define a contract (a set of methods) that classes must implement but don't necessarily share any implementation.
- Use an Abstract Class when you need to define a common base class with shared behavior (methods) and possibly shared state (fields), and you want to provide some functionality that can be shared by subclasses.

2.Multiple Inheritance
- Interfaces allow a class to implement multiple interfaces, which is useful if your class needs to inherit behaviors from multiple sources. This is a form of multiple inheritance.
- Abstract classes only allow single inheritance. A class can extend one abstract class, but it cannot extend multiple classes.

3. Shared Behavior (Method Implementation)
- Abstract Class: If you want to provide default behavior (method implementations) that can be inherited by subclasses, an abstract class is appropriate. It allows you to write code in the base class and reuse it in derived classes.
- Interface: Interfaces are typically used to define methods that must be implemented, without providing any implementation details.

4. State (Fields/Variables)
- Abstract Class: An abstract class can have instance variables (fields), which can store state that is shared among its subclasses.
- interface :  They can only have method signatures (abstract methods) or static final variables (constants).

5. Flexibility
- Interface: Use interfaces when you need flexibility. A class can implement multiple interfaces, so if your design requires multiple behaviors to be added to a class, interfaces are a better choice.
- Abstract Class: Use abstract classes when your design is more hierarchical and you're modeling a family of related classes that share a common structure or behavior.
******************************************************14. Transient vs scoped lifetime ********************************************
Transient: 
	Creation: A new instance of the service is created every time it is requested.
	Use Case: Best for lightweight, stateless services where each request should have a new instance.
If you register a service as transient, like:
	services.AddTransient<IMyService, MyService>();
- Memory Management: Since a new instance is created every time, it might lead to increased memory usage, but it's very appropriate for short-lived operations that don't hold state between requests.

Example:
If a controller calls the service twice during one HTTP request, it gets two different instances.
---------------------------
Scoped:
	Creation: A new instance is created once per HTTP request or per scope. If you have nested scopes (like in background jobs or explicit scopes), a new instance is created for each scope.
	Use Case: Best for services that should be shared within the same request or scope but should not be shared across requests. 
If you register a service as scoped, like:
	services.AddScoped<IMyService, MyService>();

Example:
If a controller calls the service twice during the same HTTP request, it gets the same instance both times.

public sealed class Scoped                   
{
	private Scoped instance;			
	
	public Scoped(){}						
	
	public Scoped getInstance();
	{
		if(instance == null)
		{
			return new Scoped();
		}
		return instance;
	}
	
}
-------------------------------------------------------

public class Transient                   
{	
	public Transient(){}						
	
	public Transient getInstance();
	{		
		return new transient();
	}
}
***********************************15.Sealed class and Static class difference**********************************
Sealed Class:
	- Purpose: A sealed class is used when you want to prevent other classes from inheriting your class. 
			   This can be useful for maintaining control over the behavior of the class and ensuring that it cannot be modified through inheritance.
			   
	- A sealed class can be instantiated (we can create object of seald class)
	- sealed class can contain static and non static member.
Static Class:
	- Purpose: A static class is useful when you want to group methods or properties that don't require an instance of the class to be used,
	- You cannot instantiate a static class. 
	- can not contain non static member. 

*********************************16. Major Difference Between Sql Server and PostGreSql*********************************

SQL Server-----vs--------PostgreSQL

1.Relational database management system ----   Object-relational database management system
2.Commercial product from Microsoft  ------  Open source (completely free) 
3.Primarily designed for Windows, but recent versions also support Linux. ------ can run on various operating systems including Windows, Linux, and macOS.
******************************************** Why we create db connection as Singleton life cycle******************************
1.Thread Safety
In multi-threaded applications, a Singleton ensures that only one thread can access the database connection at any given time, preventing conflicts and data corruption. This makes it easier to avoid issues where multiple threads might try to access or modify the database simultaneously.

2.Centralized Management: 
With a Singleton, managing the connection (like closing or refreshing it) becomes much easier. You can control connection lifecycle events in a single, well-defined place, improving maintainability and scalability.

**********************************************17.IActionResult******************************
IActionResult is an interface used in controller methods to return flexible HTTP responses. Instead of always returning just data (like User object), it lets you return different types of results, such as:

Ok() ‚Üí HTTP 200
NotFound() ‚Üí HTTP 404
BadRequest() ‚Üí HTTP 400
Created() ‚Üí HTTP 201

1.IActionResult ‚Äì Flexible, but not strongly typed
[HttpGet("{id}")]
public IActionResult GetUser(int id)
{
    var user = UserStore.User;

    if (user == null || user.Id != id)
        return NotFound(); 		// returns 404

    return Ok(user); 			// returns 200 with the user data
}
------------------------------------------------------------------
2. ActionResult<User> ‚Äì Recommended for most APIs
[HttpGet("{id}")]
public ActionResult<User> GetUser(int id)
{
    var user = UserStore.User;

    if (user == null || user.Id != id)
        return NotFound();

    return Ok(user); // or just return user;
}
‚úÖ ActionResult<T> allows you to return either the object or an HTTP result.
-----------------------------------------------------------------
3Ô∏è.User ‚Äì Basic, only returns data (200 OK)
[HttpGet("{id}")]
public User GetUser(int id)
{
    return UserStore.User; // Always returns 200 OK
}
‚ùå No way to return an error or 404 response.

-----------------------------IActionResult vs ActionResult---------------------------
IActionResult:
IActionResult is a interface representing different HTTP results like View(), NotFound(), Redirect(). It allows flexibility to return various result types.
Perfect for MVC controllers where you render views or perform redirections.

ActionResult:
ActionResult<T> is a generic wrapper that combines a return type like student with an HTTP status code. best suited for APIs where you return data and status in one.
****************************************18.SOLID Principle***********************************************************************

The SOLID principles are a set of five principles in object-oriented programming to make software designs more understandable,
flexible, and maintainable. Each letter in "SOLID" stands for a different principle:

1) Single Responsibility Principle (SRP):
A class should have only one job or responsibility. 
This principle helps in keeping classes focused and easier to maintain.
ForEx: 
public class Employee
{
	public int ID {get; set;}
	public string name{get; set;}
	
	CalculateSalary(Employee e){...}        ‚ùå<-------------this method should not be here 
}

public class SalaryCalculate
{
	public double CalculateSalary(Employee e){...}
}

2) OCP(open close principle)
Open for extension Closed for modification Principle.
rather than modifying the existing class inherit and create a new class.

forEx:
public class SalaryCalculateForManager : SalaryCalculate
{
	public override double CalculateSalary(Employee e)
	{	
		return 2000;
	}
}
Existing flow will not affect if we want to add changes we inherit this class and create new class.

3) Liskov Substitution Principle (LSP):

Objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program. 
This principle ensures that inheritance is used correctly.

public abstract class Bird
{
    public abstract void Move();
}

public class Sparrow : Bird
{
    public override void Move()
    {
        Console.WriteLine("Sparrow is flying.");
    }
}

public class Penguin : Bird
{
    public override void Move()
    {
        throw new NotImplementedException("Penguin is swimming");
    }
}

public void MakeBirdMove(Bird bird)
{
    bird.Move();
}

Bird sparrow = new Sparrow();
Bird penguin = new Penguin();

MakeBirdMove(sparrow);  // Output: Sparrow is flying.
MakeBirdMove(penguin);  // Output: Penguin is swimming.

4) Interface Segregation Principle (ISP):
-means any code should not be forced to use methods which it does not need.

-This principle advocates for the creation of specific, smaller interfaces instead of one large interface, 
which helps in keeping dependencies minimal and specific to the client's needs.

5) Dependency Inversion Principle (DIP):

High-level modules/classes should not depend on low-level modules/classes directly. But should access it via abstractions (e.g., interfaces). 

This principle promotes loose coupling between software modules, making the system more maintainable and allowing for easier substitution of components.

public class HomeController  	<--- high level module
{
	InternalEmpoyee e = new InternalEmpoyee();   <---  low-level module
}

instead of above 

public Interface IEmployee
{}
public class internalEmployee : IEmployee
{

¬†¬†¬† public void Work()
¬†¬†¬† {
¬†¬†¬†¬†¬†¬†¬† Console.WriteLine("Internal employee is working.");
¬†¬†¬† }

}

public class ExternalEmployee : IEmployee
{
	public void Work()
	¬†¬†¬† {
	¬†¬†¬†¬†¬†¬†¬† Console.WriteLine("Internal employee is working.");
	¬†¬†¬† }
}
public class HomeController
{
	private readonly IEmployee _iemployee;
	public HomeControler(IEmployee e)
	{
		_iemployee = e;
	}
	
	public void ManageEmployee()
¬†¬†¬† {
¬†¬†¬†¬†¬†¬†¬† _employee.Work();
¬†¬†¬† }

}


public static void Main(string[] args)
{
¬†¬†¬†¬†IEmployee internalEmployee = new InternalEmployee();
¬†¬†¬†¬†HomeController homeControllerInternal = new HomeController(internalEmployee);
¬†¬†¬† homeControllerInternal.ManageEmployee();¬† // Output: Internal employee is working.

¬†¬†¬†¬†IEmployee externalEmployee = new ExternalEmployee();
¬†¬†¬†¬†HomeController homeControllerExternal = new HomeController(externalEmployee);
¬†¬†¬†¬†homeControllerExternal.ManageEmployee();¬† // Output: External employee is working.
}


*********************************************************19.Agile methodology****************************************************
Agile methodology is an iterative approach to project management and software development that emphasizes flexibility, collaboration, and customer feedback.
Here are some key concepts:
-Iterative Development: Projects are broken down into small, manageable sprints, typically lasting 1-4 weeks. Each iteration results in a working product increment.
-Collaboration: Agile promotes strong communication among team members and stakeholders. Daily stand-up meetings help keep everyone aligned and address any blockers.
-Customer Involvement: Continuous customer feedback is integral. Stakeholders review each increment to ensure the product meets their needs and can suggest changes.
-Adaptive Planning: Plans can evolve based on feedback and changing requirements. This allows teams to be more responsive to new information.
-Cross-Functional Teams: Agile teams are typically composed of members with various skills, enabling them to take ownership of different aspects of the project.
-Focus on Deliverables: The aim is to deliver a usable product quickly, allowing teams to gather feedback sooner rather than later.
****************************************************20.Garbage collection***********************************
static void Main()
{
	static void Call()
	{
		SomeClass x = new SomeClass();
	}									<--- X object scope
}


Total memory = manageable + unmanaged memory

object is create in heap memory and reference will be in stack, when object will out of scope reference will remove from stack memory. then GC remove object from heap. 
1.can we see how GC work
-> yes by using Build->performance profiler in Visual studio, and by using performance monitor in window.

2.Does GC clean primitive types?
-> No, they are allocated on stck and stck removes them as soon as the veriable goes out of scope.

3.Managed code vs unmanaged code?
- The code that run under the envirnment of CLR is called as managed code.
- All code which is compiled and conver into IL code is called as managed code.
- Managed code are those which are pure .NET object and these object are controller by .NET CLR.
- the code which does not run under the CLR called as Unmanaged code.
- unmanaged resource are those which are not controlled by .NET CLR runtime like File handle, connection objects and so on.

4.GC can clean unmanaged resource.
-> no, it clean only object which control under CLR

5. Generation
-> Generation are logical buckets which have objects and every bucket defines how much old the object are.
GC0 : Short lived objects. local objects. 
GC1 : intermediate lived object.
GC2 : long lived objects. Ex static objects.

6. why Generation
-> for improve performance

7. What is a memory leak ?
-> Memory leak is a situation where the memory consumed by the application is not returned back to the operating system, even when the application exits.

8. Can .Net application have memory leak issue even we have GC?
-> Yes, its still possible to hvae memory leaks because GC only clean managed object.
	if unmanaged memory is not claimed properly we can have memory leakss.

************************************21 Difference between Abstract class and interface********************************************
Abstract class vs Interface
1.Abstract class contain both Declaration and definitoin of method.  vs only Declaration
2.Abstract class keyword: Abstract  
3.not support multiple inheritance
4.can have constructor

*************************************22. Model binding*******************************
Model binding is a concept commonly used in web development frameworks to automatically map data from HTTP requests (such as form data, query strings, route data, or JSON payloads) to the parameters of a method, typically in a controller.

Request : Name=John&Email=john@example.com&Age=30
public class User
{
    public string Name { get; set; }
    public string Email { get; set; }
    public int Age { get; set; }
}

[HttpPost]
public IActionResult CreateUser(User user)
{
    // Model binding automatically populated the 'user' object
    // from the incoming form or JSON data.
    // Now you can use the 'user' object directly.
    return Ok(user);
}

---------difference between GET and POST--------------
GET request ‚Äî data is sent as URL query parameters, like your example:
http://localhost/api/employee?Name=akash&location=Pune

POST request ‚Äî data is usually sent in the request body, not in the URL.
http://localhost/api/employee

header 
Content-Type: application/json

body
{
  "Name": "akash",
  "location": "Pune"
}

*************************************23. Filter and Middlewares in ASP .NET Core****************************
Filters in ASP .NET Core MVC
https://youtu.be/dot1mWiXVjg?si=LsKqHgDAecYy6AUf
https://youtu.be/zAG8VnOFxGA?si=iYlYuKIFpZnnu5eK
---#Defination:	
filter is set of code which execute before or after any action method, basically Filter run within the ASP.NET Core action invocation pipline,

#Use: Once we create any filter we can use this for multiple action method by using []. to use can avoid having repeat code.

---#Request structure---
request-> Middleware->Filter->Controller

Request
	|
Other Middleware
	|
Routing Middleware
	|
Action Selection
	|
    |
-----------------------------------------------
|MVC Action invocation Pipline(Filter Pipline) |
-----------------------------------------------

---#Difference between Middleware and Filter---
1.Middleware execute on request pipline where as Filter execute on filter pipline(Action Invocation pipline)
2.Middleware apply the rule to every request, including the api calls. Filter only need the rule for specific controller or actions

---#Types of Filters and order---
1.Authorization filters
2.Resource Filter (Call after auth filter and after Result filter)
3.Action Filter
4.Exception Filter (Execute if error occure)
5.Result Filter (Call before and after result)

---------------------------Authorization Filter-------------------------
Authorization filter:- this filter will run before other filter to determine whether a user is authorized to access a resource
Ex:- if we have some api which only access by admin that time we use this filter
[Authrize(Role="Admin")]

senario 2
only pro subscription customer can access resource
Create custom filter

public class ProSubscriptionFilter: IAuthorizationFilter
{
	public ProSubscriptionFilter(ApplicationDbContext dbContext)
	{
		_dbContext = dbContext;
	}
	
	public OnAuthorization()
	{
		//check use is pro from db
	}
}

then this filter we use on pro plan controller

[ProSubscriptionFilter] / [ServiceFilter(typeof(ProSubscriptionFilter))]
public class ProController: Controller
{
}
------------------Resource Filter Implementation----------
need to inherit IResourceFilter and those methos OnResourceExecuted and OnresourceExecuting
---------
public class ResourceFilter : Attribute, IResourceFilter
{
	private readonly IMemoryCache _cache;
	public ResourceFilter(IMemoryCache cache)
	{
		_cache = cache;
	}
	public void OnresourceExecuting(ResourceExcutingContext context)
	{
		//return data from cache
		Console.Writeline("ResourceFilter OnResourceExecuting method");
	}
	
	public void OnResourceExecuted(ResourceExcutedContext context)
	{
		//set data into cache for specific time(5min)
		Console.Writeline("ResourceFilter OnResourceExecuted method");
	}
}

problem.cs
builder.Services.AddMemoryCache() //enable in-memory caching
builder.Service.AddScoped<ResourceFilter>(); // register the filter 


this will load data from Cache which reduce db calls and improve performace.
-------------------------------Action Filter----------------------------
Action Filter: Action filter execute before and after Action Execute
#Action Filter Implementation

public class CutomActionFilter: Attribute, IActionFilter
{
	public void OnActionExecuting(ActionExecutingContext context)
	{
		Console.Writeline("CustomActionFilter OnActionExecuting method")
	}
	public void OnActionExecuted(ActionExecutedContext)
	{
		Console.Writeline("CustomActionFilter OnActionExecuted method");
	}
}
-------------------------------Exception Filter----------------------
Exception Filter:- will run when an unhandled exception occures

public class CustomExceptionFilter : IExceptionFilter
{
	public void OnException(ExceptionContext context)
	{
		switch(context.Exception)
		{
		 case ArgumentNullException
			throw ex with proper msg
			break;
		 case UnauthorizedAccessException
			throw ex with proper msg
			break;
			.
			.
			.
		}
	}
}
register filter in program.cs file
builder.service.AddControllersWithViews(option=>
{
	option.Filter.Add<CustomExceptionFilter>(); 
})

---------------------Result Filter------------------------
#Result Filter:- filter run immediately before and after the execution of an action result. by using this filter we can check time taken by Action by using stopwatch to check performace.

use: when we have 2 method whose perpose is same so by using this filter we can check the performace.

-----------------------------------------------
[Route("Index")]
[ResourceFilter]            <------resource Filter used as attribute it will load data from cache and get updated data in specific time(5min)
[CutomActionFilter]        <----- Action Filter 
public ViewResult Index()
{
	//Logic
}

output : 
ResourceFilter OnResourceExecuting method
CustomActionFilter OnActionExecuting method
//logic
CustomActionFilter OnActionExecuted method
ResourceFilter OnResourceExecuted method
-------------------------------------------------------

-------#Build-in filters---------
1.ResponceCache Filter, 
2.Authorize

---responceCache filter implementation---
in statup.cs
builder.service.AddResposeCaching()
app.UseResponseCachong()
-------------------
Authontication filter
builder.service.AddAuthentication();
app.UseAuthentication()						<--- we do this for use Filter as a Attribute([Authorize],[ResponceCache])					

-----------------
in class
[HttpGet]
[Authorize]
[ResponceCache(Duration=60)]		<--- save the api responce it 1 min
public async Task<IActionResult>Get()
{
	return Ok();
}
----------------------------------------------Middleware-----------------------------------
What is Middleware in ASP.NET Core?
https://youtu.be/UIkV-sLdEuE?si=jX_OH0b81iRLaCMB
middleware is a powerful feture in asp .net core that allow as to control request and respose globally.
-> we have configure method in statup file and as we see we calling serveral component like
app.UseStaticFiles()
app.UseRouting()
app.useAuthorization()
app.UseCors
app.UseSwagger();    
all this is nothing but the middlewares only

Defination: A middleware a component that is executed on every Requiest in the ASP.NET Core application.

whenerver any requst come that request pass through all the middleware and then it will go to the controller

Order
app.UseHttpRedirection()-> app.UseStaticFiles()->app.UseRouting()-> app.UseSession->app.UseAuthentication()-> app.UseAuthorization();

Middleware work before the request reaches the controller
*************************************************24.Action Parameters*********************************
Action Parameters

1. [FromBody]
- Binds data from the request body.
- Typically used for complex objects sent as JSON or XML.
- Only one per action allowed

[HttpPost]
public IActionResult Create([FromBody] Product product)

POST /api/products
Content-Type: application/json

{
  "Id": 1,
  "Name": "Apple"
}
----------------------------------------------------------
2. [FromQuery]
- Binds simple or complex data from the query string.
- Used for filtering, paging, sorting, or any data sent via URL parameters.
- Multiple allowed

[HttpGet]
public IActionResult GetProducts([FromQuery] string category, [FromQuery] int page = 1)

GET /api/products?category=fruit&page=2
----------------------------------------------------------
3.FromHeader : it will return header information

*****************************************25. data coming in json formate how to get and return in json formate***********************
1. Create Model class
2. Create a web api controller method
	public IActionResult PostBook([FromBody] Book book)
    {
		    return Ok(new book);
	}
3.[FromBody] tells ASP.NET Core to bind the JSON request body to the book parameter.
4.return Ok(...) automatically returns a JSON response.

******************************26. What is a secret key and why is it required?*************************
A secret key is a private string used to sign and verify tokens, like JWTs. It makes sure that the data comes from a trusted source and hasn‚Äôt been changed.
It‚Äôs required to:
1. Secure the token
2. Prevent fake tokens
Without the secret key, anyone could generate or modify tokens, which would be a big security risk.
******************************27. Approchs for secure APIs using JWT***************************************
 1. Apply Authorization Globally (Best Practice for APIs)
	Instead of using [Authorize] on each controller or method, you can enforce it for the entire application in Program.cs or Startup.cs.
	builder.Services.AddControllers(options =>
	{
		var policy = new AuthorizationPolicyBuilder()
			.RequireAuthenticatedUser()
			.Build();
		options.Filters.Add(new AuthorizeFilter(policy));
	});
	This means all endpoints require a valid JWT, unless explicitly marked with [AllowAnonymous].

	üîì Use [AllowAnonymous] for public endpoints like /login or /register
 2. use [Authorize]
 it's the recommended and cleanest way to secure specific routes.

##################################‚úÖ Coding problems #######################################################

1.give me no of occuerence for each word from hello (count)

 static void Main()
    {
        string input = "hello";

        // Use LINQ to group characters by their value and count the occurrences
        var charCount = input.GroupBy(c => c)
                             .Select(group => new { Char = group.Key, Count = group.Count() })
                             .ToList();

        // Display the character counts
        foreach (var item in charCount)
        {
            Console.WriteLine($"{item.Char} : {item.Count}");
        }
    }
	
---------------------------or-------------------------------
string s = "AkAsh";
var disc = new Dictionary<char, int>();
for (int i = 0;i< s.Length;i++)
{
    if (disc.ContainsKey(s[i]))
    {
        disc[s[i]]++;
    }
    else
    {
        disc.Add(s[i], 1);
    }
}
foreach (var item in disc)
{
    Console.WriteLine(item.Key + " : "+item.Value);
}
AKASH
###################################################‚úÖ Database#################################################################
****************************************1.In SQL how do you optimize stored procedures****************************************
1. use SET NOCOUNT ON 
when we do insert or update query  in sql it will show 1 row affected masseges. no need to see the masseges,bcz it occupay some memory. thats why use SET NOCOUNT ON;

2. use specific column name instead of * to get all record.
ex: select empName, Department, city from emp;

3. use schema name before object or tablenames.
if you have more than one schema then it will check on all table from schemas. instead of that use schema name before tableName.
ex: SELECT EMPId, Name FROM dbo.EmployeeTable;

4. use indexes for search or create index for commonly used column in where conditions.
- By default, when you create an index using the CREATE INDEX statement without specifying the type, SQL Server creates a non-clustered index.
-Indexing in SQL Server (and other database management systems) is a technique used to speed up data retrieval operations. It works similarly to an index in a book, where you can quickly locate the page number associated with a specific topic.
- Instead of scanning the entire table to find the desired data, SQL Server uses indexes to locate rows more efficiently.

# What is an Index?
An index is a data structure that SQL Server uses to improve the speed of data retrieval. It stores pointers to the actual data rows in a table, allowing SQL Server to quickly access the data without scanning every row in the table.
create index idx_dep_emp ON EmployeeTable(Department);

5. use numeric fields to store numeric value instead of character 
Ex: if i have age column instead of using varchar use TINYINT(range 0 to 255), It uses only 1 byte of storage,

additional info
VARCHAR(50):
If the column contains a string of length 10 (e.g., "HelloWorld"), 
it would use 10 bytes for the string data and 2 bytes for the length tracking, totaling 12 bytes.

6. use varchar or nvarchar instead of char
becouse
- char is fixed-lenght data type. this means that sql server reserve exact amount of space defined in the column.
for example if you define a column as CHAR(50) and store a string of length 10, SQL Server will still allocate 50 bytes for that string
- VARCHAR is a variable-length data type. This means SQL Server only allocates the exact number of bytes needed to store the data, plus 2 bytes for length tracking.
for example  if you define a column as VARCHAR(50) and store a string of length 10, SQL Server will only allocate 10 bytes for the string (plus 2 bytes for the length), instead of the full 50 bytes.

7. Minimum use DISTINCT keyword.
avoid to use DISTINCT keyword becouse it take time for processing instead of that use groupBy 
Ex: 
SELECT DISTINCT Department from employeeTable  <----- Don't use
SELECT Department from employeeTable Group By Department <---- most preferable

8. use Exists instead of count
when you want to show department which contain at least one employee that time use Exists instead of count
bcouse :
count will scan all matching rows to determine the total count, which can be slower if there are a large no of row,
Exists Checks for the existence of rows that meet a condition. It returns TRUE if the subquery returns at least one row, and FALSE if it returns no rows. It stops processing as soon as a row is found that matches the condition.

SELECT d.DepartmentID, d.DepartmentName
FROM Departments d
WHERE (
    SELECT COUNT(*)						<----- don't use
    FROM Employees e
    WHERE e.DepartmentID = d.DepartmentID
) > 0;
-----------------------------------------
SELECT d.DepartmentID, d.DepartmentName
FROM Departments d
WHERE EXISTS (						   <---- most preferable
    SELECT 1
    FROM Employees e
    WHERE e.DepartmentID = d.DepartmentID
);

************************************2.Difference between VARCHAR and NVARCHAR***************************************************
VARCHAR:
- Stores non-Unicode data, meaning it uses the ASCII character set.
- Each character takes 1 byte of storage.
- If the column is defined as VARCHAR(50), it can store up to 50 characters using 50 bytes of storage (plus 2 bytes of overhead for length tracking).
NVARCHAR:
- Stores Unicode data, which can represent characters from any language in the world (including Asian, European, and special characters like emojis).
- Each character takes 2 bytes of storage. 
- If the column is defined as NVARCHAR(50), it can store up to 50 characters but will use 100 bytes for the data (plus 2 bytes of overhead for length tracking).

SQL VS SQL server : SQL is Query languge, while SQL Server is a DataBase managment System.
					SQL is Query languge for working with a relational DB while SQL server is software that perform SQL query.

DataBase: A Db is a structured collection of Data that is organized and Stored in a way that allows for efficient retrival, manipulation 


***********************************3.SQL Command/ Type of DB languge******************************************************
DB languge are used to read, update, and Store Data in DB. There are several languges can be used for this porpose
1. Data defination languge(DDL) : Used to define DB Schema 
								  Ex. Create,Drop,Truncate, Alter
2. Data Manupulation languge(DML) : Used to Manupulat Data for ex. Insert, update, Delete, Select
3. Data Control languge(DCl) : DCl mainly Dels with rigths and permissions and other Controls Ex. Grant and revoke.
4. Transaction Control languge(TCL): TCL Dels with transaction within DB, EX. Commit, Rollback, Savepoint

************************************4.ACID Property*************************************************************************

ACID is stands for Atomicity, Consistency, Isolation and Durability
1.Atomicity:- Every Transaction Should be execute as a single unit means all the step should happen or none should happen there is no partial execution.
Ex: Imagine you're transfer 100rs from your account to friend's account so in that we have 2 steps
	1. Deduct 100rs from your account.
	2. Add 100rs to your friends account.
	if step 1 is succeeds but step 2 is fails, and money is deducted from your account but not added to your friends account that's incorrect.
or 	if step 2 is succeeds but step 1 is fails means money not duducted from your account but aaded in friends account that's also incorrect.
so atomicity say transaction trated as one single unit both steps should happen or not any step happen.
------------------
2.Consistency:- Onec the transaction is executed It should move from one Consistent state to another.
	ex: you have 500rs in your account and you trying to withdrow 800rs which is wrong it violates the rule. so consistancy will not allow this transaction. 
------------------
3.Isolation:- Isolation means that concurrent transactions done without interfere with each other.
	ex: If Two people try to book the movie ticket at the same time within that only one transaction will succesfully book seat other will waiting or fail. so no double booking occurs.			
4.Durability:- After succesfully complete the trasaction changes in the DB is persist				
	ex: Imagine you are order some item from e-commerce webside you enter peyment details and click on Order button. the details of the transaction, Items are saved permanently in database. even if the power goes or the server crashes or serveryour oder data remain safe.
***************************************5.Store Procedure VS function*********************************************************
1. SP Can return 0, single or multiple value, function Can return single value Which is Mandatoy.
2. SP Can have Input and Output parameter , function have only Input parameter.
3. We can Call Function from SP, But not fuction call SP.
4. we cant use SP in select, where or Having statment, but function use.

#Type of Functions
1. Single Row Function : sqrt(10),abs(10),round(12.34), Ceil(234.2), floor(2.133)
2. Aggregate Function : sum, min, max,count,avg.

****************************************6.Joins, View, Trigger****************************************************
#Inner Join : inner Join return only the row from both table where they are match based on join condition.
#Outer join : Outer Join return all row from one table and matching row from other table Based on join condition.
#Left Join : return All Row from left table and matching row from rigth table.

#View: 	View in SQL are Consider as a virtual table. A view also Contain rows and Columns It is used to give Limited access to the table to hide Complex Query
		It Provide Security for hiding Table Name.
		- it simplified Querying
		- Data security
		- Code
#Trigger: trigger are spacial procedure which gets executed automatically when user performs some action this is used for maintian the logs
- Trigger timing = After : It will Execute use Action First then Execute Trigger 
				   Before: it will Execute Trigger First then Action
		
- Query : Create trigger triggerName before insert on tableName for each row
			begin
				insert into tableLogs values(...);
			end;
				   
**********************************************7.Normalization**************************************************************
- Normalization is a process of Organizing the Data in Database to avoid data redundancy, insertion,updation,deletion anomly
- Normalization Divide larger table into the smaller table and links Them using relationship
#1st NF : The relation will be 1NF if it contain an atomic Value. means table Cannot hold multiple value.
			Ex. EmpName | PhoneNo <- phoneNo Cannot be Multiple
#2nd NF : a relation must be in 1stNF and relation should not any partial dependency.
			Ex. TecherId | TecherAge | Subject => TecherId | TecherAge & TecherId | Subject

#3rd NF : The relation will be in 3NF if is in 2NF and not contain any transitive partial dependency   
			EX. EMPID | Name | ZIP | STATE | CITY =>  EMPID | Name | ZIP  &  ZIP | STATE | CITY 
			
****************************8.What is the use of temp tables and table variable**********************************************
#TEMPORARY TABLES (#TempTable):-
	Use: 	- To store temporary data during a session or connection. 
			- Often used for intermediate result sets, large datasets, or complex joins.
			- Stored in tempdb
	EX:-
	CREATE TABLE #TempTable (
	  Id INT,
	  Name VARCHAR(50)
	)

	INSERT INTO #TempTable VALUES (1, 'Alice'), (2, 'Bob')

	SELECT * FROM #TempTable

#TABLE VARIABLES (@TableVar):-
	 Use: - To hold small sets of data temporarily within a batch or stored procedure.
		  - Good for lightweight, quick operations.
		  - Lives only within the scope where it's declared
	 Ex:- 
	 DECLARE @TableVar TABLE (
	  Id INT,
	  Name VARCHAR(50)
	)

	INSERT INTO @TableVar VALUES (1, 'Alice'), (2, 'Bob')

	SELECT * FROM @TableVar

	 
##################################################‚úÖ SQL Query Problems#######################################################
1.Second highest salary and third highest salary
2. All element not duplicate SQL query
3. Retrieve duplicate records from a table
4. Delete duplicate rows from a table while keeping one copy
5.What are INNER JOIN, LEFT JOIN, RIGHT JOIN, and FULL OUTER JOIN? Give examples.
6.Find employees who earn more than the average salary in their department.
7. Find employees who do not belong to any department (use LEFT JOIN).
8.Query to get employees who joined in the last 30 days.
9.What is the difference between ROW_NUMBER(), RANK(), and DENSE_RANK()?

------------------------------------------------------------------------------------------
1.Second highest salary and third highest salary

1. second highest sal

SELECT MAX(Salary) 
FROM Employees 
WHERE Salary < (SELECT MAX(Salary) FROM Employees);

SELECT DISTINCT TOP  1 sal
  FROM [iacsd0923].[dbo].[emp] where sal NOT IN (SELECT TOP 1 sal FROM [iacsd0923].[dbo].[emp] ORDER BY sal DESC) order by sal desc;

select top (1) * from dbo.emp where SAL Not In (select Top 1 SAL FROM DBO.emp ORDER BY SAL desc) order by SAL desc

2. third highest sal
SELECT DISTINCT TOP  1 sal
  FROM [iacsd0923].[dbo].[emp] where sal NOT IN (SELECT TOP 2 sal FROM [iacsd0923].[dbo].[emp] ORDER BY sal DESC) order by sal desc;
------------------------------------------------------------------------------------------
2. All element not duplicate SQL query
SELECT DISTINCT column_name FROM table_name;
column where you want to remove duplicates.
----
If you want to remove duplicates based on multiple columns,
SELECT DISTINCT column1, column2 FROM table_name;

------------------------------------------------------------------------------------------
3. Retrieve duplicate records from a table
SELECT column_name, COUNT(*) 
FROM table_name 
GROUP BY column_name 
HAVING COUNT(*) > 1;

------------------------------------------------------------------------------------------
4. Delete duplicate rows from a table while keeping one copy

DELETE e1 from EmpTable e1, EmpTable e2 
WHERE e1.empName = e2.empName and e1.empId > e2.empId;

------------------------------------------------------------------------------------------
5.What are INNER JOIN, LEFT JOIN, RIGHT JOIN, and FULL OUTER JOIN? Give examples.
Write a query to fetch employee details with the department name. (Assume Employees and Departments tables)

#INNER JOIN

	SELECT E.Name, D.DepartmentName
	FROM Employees E
	INNER JOIN Departments D
	ON E.DepartmentID = D.DepartmentID;
	
#LEFT Join
	SELECT E.Name, D.DepartmentName
	FROM Employees E
	LEFT JOIN Departments D
    ON E.DepartmentID = D.DepartmentID;
------------------------------------------------------------------------------------------
6.Find employees who earn more than the average salary in their department.
	SELECT E.Name, E.Salary, E.DepartmentID
	FROM Employees E
	WHERE E.Salary > (
    SELECT AVG(Salary)
    FROM Employees
    WHERE DepartmentID = E.DepartmentID
	);
------------------------------------------------------------------------------------------
7. Find employees who do not belong to any department (use LEFT JOIN).
	SELECT E.EmployeeID, E.Name, E.DepartmentID
	FROM Employees E
	LEFT JOIN Departments D
    ON E.DepartmentID = D.DepartmentID
	WHERE D.DepartmentID IS NULL;
------------------------------------------------------------------------------------------
8.Query to get employees who joined in the last 30 days.
	SELECT EmployeeID, Name, JoinDate
	FROM Employees
	WHERE JoinDate >= DATEADD(DAY, -30, GETDATE());
#employees who joined in the last 15 year.
	SELECT * from emp where HIREDATE > DATEADD(YEAR,-15,GETDATE());
------------------------------------------------------------------------------------------
9.What is the difference between ROW_NUMBER(), RANK(), and DENSE_RANK()?
-> ROW_NUMBER(), RANK(), and DENSE_RANK() are all ranking functions in SQL Server
#ROW_NUMBER():
	- Assigns a unique sequential number to each row.
	- No duplicates ‚Äî even if rows have the same values in the ranking column.
	- Gaps don't matter because the number is always incremented by 1.

	SELECT Name, Salary,
    ROW_NUMBER() OVER (ORDER BY Salary DESC) AS RowNum
	FROM Employees;
	
#RANK()
	- Assigns same rank to ties, but skips the next ranks.
	- So, if two employees tie at rank 1, the next rank will be 3.
	
	SELECT Name, Salary,
    RANK() OVER (ORDER BY Salary DESC) AS RankNum
	FROM Employees;
	
DENSE_RANK()
	- Also assigns same rank to ties, but doesn‚Äôt skip the next rank.
	- If two employees tie at rank 1, the next rank will be 2.
	
	SELECT Name, Salary,
    DENSE_RANK() OVER (ORDER BY Salary DESC) AS DenseRankNum
	FROM Employees;
--------------------------------------------
10. Database constraint
	1.NOT NULL
	2.UNIQUE
	3.PRIMARY Key
	4.FOREIGN KEY 
		CREATE TABLE Orders (
			OrderId INT NOT NULL,
			OrderNumber INT NOT NULL,
			PersonId INT,
			PRIMARY KEY (OrderId),
			FOREIGN KEY (PersonId) REFERENCES Persons(PersonID)
		);
	5.CHECK
		CREATE TABLE Persons(
			ID int NOT NULL,
			FirstName varchar(255),
			Age int CHECK(Age>=18)
			);
	6.DEFAULT
		CREATE TABLE Persons(
			ID int NOT NULL,
			LastName varchar(10) NOT NULL,
			City varchar(10) DEFAULT 'PUNE'
			);

--------------------------------------------------------------------------------------------
L & T   done

->‚Ä¢  Dependacy injection details: -Singleton pattern, Using constructor. Scoped, Transients
->‚Ä¢  Lazy loading
->‚Ä¢  How routing work in dotnet
‚Ä¢  SQL Servers basic, Mongodb basic
->‚Ä¢  Performance issue in query ( do indexing)-
‚Ä¢  How you Dockeries your application
‚Ä¢  Jenkins 
‚Ä¢  CICD-Pipeline
* When to use Filters and Middle-ware



Capgemini 

->‚Ä¢‚Ä¢ Difference between Abstracting & Encapsulation
->‚Ä¢‚Ä¢ Authentication and Authorization different
->‚Ä¢‚Ä¢ what is Dependacy injection and their types
->‚Ä¢‚Ä¢ In SQL how do you optimize stored procedures -
->‚Ä¢‚Ä¢ Delete and Truncate difference
->‚Ä¢‚Ä¢ Different Http method commonly
->‚Ä¢‚Ä¢ PUT and PATCH difference
->‚Ä¢‚Ä¢ Second highest salary and third highest salary
‚Ä¢‚Ä¢ How many type Filters? Authorizes authentication
‚Ä¢‚Ä¢ Basic life of angular? Bootstrap function
‚Ä¢‚Ä¢ what are absorber in angular
‚Ä¢‚Ä¢ what is Bootstrap ? 
‚Ä¢‚Ä¢ code question Count occurrences of a character in a repeated string


Cybage
->‚Ä¢‚Ä¢ Put and Post different limit
->‚Ä¢‚Ä¢ Add Singleton why we choose
‚Ä¢‚Ä¢ SDLC life cycle
Sprint planning retrospective meeting, grooming, current roles and responsibilities, how communication happens within team and product owner
‚Ä¢‚Ä¢ How QA process done in your project
‚Ä¢‚Ä¢ Bug raise how do you manage hot fixes, branch merging strategy, and testing for production bugs
‚Ä¢‚Ä¢ How you will dicide which scope we have to pick from dependacy scope
If we want a service class instance which registered as DI, But the class where we create Di of that service, we creating it manually, in that case DI will not work, how will you get instance. Service provider read
->‚Ä¢‚Ä¢ Why we create db connection as Singleton life cycle
‚Ä¢‚Ä¢ Asynchronous process explain? 
Why asynchronous is not default in net, what will happen
‚Ä¢‚Ä¢ Parallel processing 
‚Ä¢‚Ä¢ Middleware and filter type explains in details
middleware is applied globally to all requests, while filters are used to target specific situations
‚Ä¢‚Ä¢ Generic class are you created
Yes, generic classes are beneficial because they allow for code reuse, type safety, and better performance
Why not we use post method for update
‚Ä¢‚Ä¢ why we use http client factory not directly http client
‚Ä¢‚Ä¢ Comprehensive methods in API include¬†API testing, caching, load testing, and penetration testing
‚Ä¢‚Ä¢ Encryption logic where you use in dotnet core
‚Ä¢‚Ä¢ Database first approach used but i want to code first approach it is possible or not if there database already exists
How will you create Entity classes for that, is any tool? 
‚Ä¢‚Ä¢ lambda expression vs lambda function
‚Ä¢‚Ä¢ which case we can go for loop and foreach loop and do while and while
‚Ä¢‚Ä¢ Test cases framework
What is Mock, multi Assertion, unit test cases basics
‚Ä¢‚Ä¢ Compression method
‚Ä¢‚Ä¢  How to send different types of data in single API response body, is it possible
‚Ä¢‚Ä¢  How to compress response body data size



Capgemini Round 2

->‚Ä¢‚Ä¢ Abstraction and encapsulation difference. 
->‚Ä¢‚Ä¢ How we decide go with abstract class or interfaces. 
->‚Ä¢‚Ä¢ Store processger and Function difference
->‚Ä¢‚Ä¢ All element not duplicate SQL query
‚Ä¢‚Ä¢ Where you apply interface and abstract class in your project. 
‚Ä¢‚Ä¢ One coding question
‚Ä¢‚Ä¢ Find the array not duplicate or unique number from array
‚Ä¢‚Ä¢ What are different way decorators? Angular
‚Ä¢‚Ä¢ Custom modules or angular modules? Angular
‚Ä¢‚Ä¢ How manually change the events? Angular


Savient Consultancy

->‚Ä¢‚Ä¢ Put and Patch difference
->‚Ä¢‚Ä¢ Scoped and Transient difference. 
->‚Ä¢‚Ä¢ Sealed class and Static class difference
->‚Ä¢‚Ä¢ use of abstract class
->‚Ä¢‚Ä¢ interface and abstract class
->‚Ä¢‚Ä¢ Overloading and overriding difference
‚Ä¢‚Ä¢ Containerize in your project could you explain. 
‚Ä¢‚Ä¢ Middleware concepts
‚Ä¢‚Ä¢ Handler concepts
‚Ä¢‚Ä¢ Http verb
‚Ä¢‚Ä¢ Highlight your technology experience. 
‚Ä¢‚Ä¢ Observable and promise difference
‚Ä¢‚Ä¢ Ngoninit and constructor difference
‚Ä¢‚Ä¢ Router outlet and router links
‚Ä¢‚Ä¢ Life cycle hooks you works 
‚Ä¢‚Ä¢ Ngon changes how it works?
 

‚Ä¢‚Ä¢ Same declaration of method in interface
Use
‚Ä¢‚Ä¢ How you handling exception in your project 
‚Ä¢‚Ä¢ what is out keywords
‚Ä¢‚Ä¢ Difference between clustered 
‚Ä¢‚Ä¢ what is Primary key? 
‚Ä¢‚Ä¢ What is cursor? 
‚Ä¢‚Ä¢ Declare int array assign value try to print this value with any loop statements or indexing. 
‚Ä¢‚Ä¢ Print array value use recursive function code c#

G+D
‚Ä¢‚Ä¢what is web api Query            https://youtu.be/BDi0A2HRNRc?si=qQDvVhPvUP8g0mqN
‚Ä¢‚Ä¢write any web api querry and filter 		https://youtu.be/BDi0A2HRNRc?si=qQDvVhPvUP8g0mqN
->‚Ä¢‚Ä¢states (client, server)
->‚Ä¢‚Ä¢httpResponce object
->‚Ä¢‚Ä¢what is coding pattern you are using 
->‚Ä¢‚Ä¢what is singleton pattern
->‚Ä¢‚Ä¢give me name from db where id is 12
->‚Ä¢‚Ä¢how routers work which types of routers we have


MG Global

1.why want to switch withing 1 year.
2.What you learn from CDAC compare Collage life
3.Why you Do CDAC
4.On Which Concept from C# you apply for job.
5.what is Abstract class when to use 
6.what is Interface when to use
7.how prevent class from inheriting
8.how prevent method from overridden
9.Final keyword use
10.how secure API
11.what is Delegate where you use
12.OAuth
13.What is RDLC
14.What is EF
15.What is Dapper
16.How do you analyse Dapper is faster 
17.static why use and other functionality
18.LINQ
19.Explain CICD means.
20.Azure service 
21.Cloud Providers
22.What is component
23.What is services
24.code snippets find output
25.Constraint in SQL
26.Find 2nd highest salary
27.Where you see yourself in 4 5 year
28.rate yourself 
29.how you keep yourself updated
30.recently facing challenges and how resolve in project
31.if you have one task on different technology and have tight Deadline how can handle
 
TSKsystem
1. string "78,56,78,89,90$79,89,87,78,89$12,45,67,78,12$56,67,78,89,75";
, represent marks of student
$ represent student
Greads 75< A
		50<B
		35<C
		0< D
		
Count Greads and return max gread;
#Code
    public char CheckMaxGrade(string str)
    {
        string str = "78,56,78,89,90$79,89,87,78,89$12,45,67,78,12$56,67,78,89,75";
        Dictionary<char, int> dic = new Dictionary<char, int>();

        string[] students = str.Split('$');

        for (int i = 0; i < students.Length; i++)
        {
            string[] marks = students[i].Split(',');
            int total = 0;

            for (int j = 0; j < marks.Length; j++)
            {
                total += Convert.ToInt32(marks[j]);
            }

            char grade = CheckGrade(total);

            if (dic.ContainsKey(grade))
            {
                dic[grade]++;
            }
            else
            {
                dic.Add(grade, 1);
            }
        }

        // Determine grade with highest count
        int max = 0;
        char result = 'D';

        foreach (var item in dic)
        {
            if (item.Value > max || (item.Value == max && item.Key > result))
            {
                max = item.Value;
                result = item.Key;
            }
        }

		return result
    }

    public static char CheckGrade(int total)
    {
        double percentage = (total * 100.0) / 500;
        percentage = Math.Round(percentage);

        if (percentage >= 75)
        {
            return 'A';
        }
        else if (percentage >= 50)
        {
            return 'B';
        }
        else if (percentage >= 35)
        {
            return 'C';
        }
        else
        {
            return 'D';
        }
    }
}


----------------------------------------------
2. Inheritance
---------------------------------------------
3. Find rick Director of India
SELECT TOP(1) 
    d.FullName AS FirstName, 
    SUM(b.Profit) AS TotalProfit,
    MAX(m.lastRelese) AS ReleaseYear
FROM 
    Directors d
JOIN 
    Movie m ON d.DirectorId = m.DirectorId
JOIN 
    boxOffice b ON m.MovieID = b.MovieID
WHERE 
    d.Country = 'India'
GROUP BY 
    d.FullName 
ORDER BY 
    TotalProfit DESC;
---------------------------------
#SWT System
1.background
2.what is appsetting.json
3.if data coming in json formate how to get and return in json formate
4.jwt secret key means?
5.how we add jwt authentication
6.what is deligate
7.explain middleware
8.How to secure api
9.role based authentication
10.Difference IActionResult and ActionResult
11.type of cache in .net core
12.how can secure api where to write logic (controller and any other way?)
13.what is Cors 
14.where you can register service
15.Lazy loading in EF
16.What is Repository pattern
17.how to secure transfer from server to client during request 
18.find 3rd highest amount from table
19.what is dense rank
20.difference between clustered non clustered index and how to create 

